<html lang="en">
<head>
<title>Rust Documentation</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Rust Documentation">
<meta name="generator" content="makeinfo 4.13">
<link title="Top" rel="top" href="#Top">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<h1 class="settitle">Rust Documentation</h1>
<div class="node">
<a name="Top"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Disclaimer">Disclaimer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#dir">(dir)</a>

</div>

<h2 class="unnumbered">Top</h2>

<p>Rust Documentation

<ul class="menu">
<li><a accesskey="1" href="#Disclaimer">Disclaimer</a>:                  Notes on a work in progress. 
<li><a accesskey="2" href="#Introduction">Introduction</a>:                Background, intentions, lineage. 
<li><a accesskey="3" href="#Tutorial">Tutorial</a>:                    Gentle introduction to reading Rust code. 
<li><a accesskey="4" href="#Reference">Reference</a>:                   Systematic reference of language elements. 
<li><a accesskey="5" href="#Index">Index</a>:                       Index
</ul>

   <p>Complete table of contents

   <div class="contents">
<h2>Table of Contents</h2>
<ul>
<li><a name="toc_Top" href="#Top">Top</a>
<li><a name="toc_Disclaimer" href="#Disclaimer">1 Disclaimer</a>
<li><a name="toc_Introduction" href="#Introduction">2 Introduction</a>
<ul>
<li><a href="#Goals">2.1 Goals</a>
<li><a href="#Sales-Pitch">2.2 Sales Pitch</a>
<li><a href="#Influences">2.3 Influences</a>
</li></ul>
<li><a name="toc_Tutorial" href="#Tutorial">3 Tutorial</a>
<li><a name="toc_Reference" href="#Reference">4 Reference</a>
<ul>
<li><a href="#Ref_002eLex">4.1 Ref.Lex</a>
<ul>
<li><a href="#Ref_002eLex_002eIgnore">4.1.1 Ref.Lex.Ignore</a>
<li><a href="#Ref_002eLex_002eIdent">4.1.2 Ref.Lex.Ident</a>
<li><a href="#Ref_002eLex_002eKey">4.1.3 Ref.Lex.Key</a>
<li><a href="#Ref_002eLex_002eRes">4.1.4 Ref.Lex.Res</a>
<li><a href="#Ref_002eLex_002eNum">4.1.5 Ref.Lex.Num</a>
<li><a href="#Ref_002eLex_002eText">4.1.6 Ref.Lex.Text</a>
<li><a href="#Ref_002eLex_002eSyntax">4.1.7 Ref.Lex.Syntax</a>
<li><a href="#Ref_002eLex_002eSym">4.1.8 Ref.Lex.Sym</a>
</li></ul>
<li><a href="#Ref_002ePath">4.2 Ref.Path</a>
<li><a href="#Ref_002eGram">4.3 Ref.Gram</a>
<li><a href="#Ref_002eComp">4.4 Ref.Comp</a>
<ul>
<li><a href="#Ref_002eComp_002eCrate">4.4.1 Ref.Comp.Crate</a>
<li><a href="#Ref_002eComp_002eAttr">4.4.2 Ref.Comp.Attr</a>
<li><a href="#Ref_002eComp_002eSyntax">4.4.3 Ref.Comp.Syntax</a>
</li></ul>
<li><a href="#Ref_002eMem">4.5 Ref.Mem</a>
<ul>
<li><a href="#Ref_002eMem_002eAlloc">4.5.1 Ref.Mem.Alloc</a>
<li><a href="#Ref_002eMem_002eOwn">4.5.2 Ref.Mem.Own</a>
<li><a href="#Ref_002eMem_002eSlot">4.5.3 Ref.Mem.Slot</a>
<li><a href="#Ref_002eMem_002eBox">4.5.4 Ref.Mem.Box</a>
</li></ul>
<li><a href="#Ref_002eTask">4.6 Ref.Task</a>
<ul>
<li><a href="#Ref_002eTask_002eComm">4.6.1 Ref.Task.Comm</a>
<li><a href="#Ref_002eTask_002eLife">4.6.2 Ref.Task.Life</a>
<li><a href="#Ref_002eTask_002eSched">4.6.3 Ref.Task.Sched</a>
<li><a href="#Ref_002eTask_002eSpawn">4.6.4 Ref.Task.Spawn</a>
<li><a href="#Ref_002eTask_002eSend">4.6.5 Ref.Task.Send</a>
<li><a href="#Ref_002eTask_002eRecv">4.6.6 Ref.Task.Recv</a>
</li></ul>
<li><a href="#Ref_002eItem">4.7 Ref.Item</a>
<ul>
<li><a href="#Ref_002eItem_002eMod">4.7.1 Ref.Item.Mod</a>
<ul>
<li><a href="#Ref_002eItem_002eMod_002eImport">4.7.1.1 Ref.Item.Mod.Import</a>
<li><a href="#Ref_002eItem_002eMod_002eExport">4.7.1.2 Ref.Item.Mod.Export</a>
</li></ul>
<li><a href="#Ref_002eItem_002eFn">4.7.2 Ref.Item.Fn</a>
<li><a href="#Ref_002eItem_002ePred">4.7.3 Ref.Item.Pred</a>
<li><a href="#Ref_002eItem_002eIter">4.7.4 Ref.Item.Iter</a>
<li><a href="#Ref_002eItem_002eObj">4.7.5 Ref.Item.Obj</a>
<li><a href="#Ref_002eItem_002eType">4.7.6 Ref.Item.Type</a>
<li><a href="#Ref_002eItem_002eTag">4.7.7 Ref.Item.Tag</a>
</li></ul>
<li><a href="#Ref_002eType">4.8 Ref.Type</a>
<ul>
<li><a href="#Ref_002eType_002eAny">4.8.1 Ref.Type.Any</a>
<li><a href="#Ref_002eType_002eMach">4.8.2 Ref.Type.Mach</a>
<li><a href="#Ref_002eType_002eInt">4.8.3 Ref.Type.Int</a>
<li><a href="#Ref_002eType_002eFloat">4.8.4 Ref.Type.Float</a>
<li><a href="#Ref_002eType_002ePrim">4.8.5 Ref.Type.Prim</a>
<li><a href="#Ref_002eType_002eBig">4.8.6 Ref.Type.Big</a>
<li><a href="#Ref_002eType_002eText">4.8.7 Ref.Type.Text</a>
<li><a href="#Ref_002eType_002eRec">4.8.8 Ref.Type.Rec</a>
<li><a href="#Ref_002eType_002eTup">4.8.9 Ref.Type.Tup</a>
<li><a href="#Ref_002eType_002eVec">4.8.10 Ref.Type.Vec</a>
<li><a href="#Ref_002eType_002eTag">4.8.11 Ref.Type.Tag</a>
<li><a href="#Ref_002eType_002eFn">4.8.12 Ref.Type.Fn</a>
<li><a href="#Ref_002eType_002eIter">4.8.13 Ref.Type.Iter</a>
<li><a href="#Ref_002eType_002eObj">4.8.14 Ref.Type.Obj</a>
<li><a href="#Ref_002eType_002eConstr">4.8.15 Ref.Type.Constr</a>
<li><a href="#Ref_002eType_002eType">4.8.16 Ref.Type.Type</a>
</li></ul>
<li><a href="#Ref_002eTypestate">4.9 Ref.Typestate</a>
<ul>
<li><a href="#Ref_002eTypestate_002ePoint">4.9.1 Ref.Typestate.Point</a>
<li><a href="#Ref_002eTypestate_002eCFG">4.9.2 Ref.Typestate.CFG</a>
<li><a href="#Ref_002eTypestate_002eConstr">4.9.3 Ref.Typestate.Constr</a>
<li><a href="#Ref_002eTypestate_002eCond">4.9.4 Ref.Typestate.Cond</a>
<li><a href="#Ref_002eTypestate_002eState">4.9.5 Ref.Typestate.State</a>
<li><a href="#Ref_002eTypestate_002eCheck">4.9.6 Ref.Typestate.Check</a>
</li></ul>
<li><a href="#Ref_002eStmt">4.10 Ref.Stmt</a>
<ul>
<li><a href="#Ref_002eStmt_002eDecl">4.10.1 Ref.Stmt.Decl</a>
<ul>
<li><a href="#Ref_002eStmt_002eDecl_002eItem">4.10.1.1 Ref.Stmt.Decl.Item</a>
<li><a href="#Ref_002eStmt_002eDecl_002eSlot">4.10.1.2 Ref.Stmt.Decl.Slot</a>
</li></ul>
<li><a href="#Ref_002eStmt_002eExpr">4.10.2 Ref.Stmt.Expr</a>
</li></ul>
<li><a href="#Ref_002eExpr">4.11 Ref.Expr</a>
<ul>
<li><a href="#Ref_002eExpr_002eCopy">4.11.1 Ref.Expr.Copy</a>
<li><a href="#Ref_002eExpr_002eCall">4.11.2 Ref.Expr.Call</a>
<li><a href="#Ref_002eExpr_002eBind">4.11.3 Ref.Expr.Bind</a>
<li><a href="#Ref_002eExpr_002eRet">4.11.4 Ref.Expr.Ret</a>
<li><a href="#Ref_002eExpr_002ePut">4.11.5 Ref.Expr.Put</a>
<li><a href="#Ref_002eExpr_002eFail">4.11.6 Ref.Expr.Fail</a>
<li><a href="#Ref_002eExpr_002eLog">4.11.7 Ref.Expr.Log</a>
<li><a href="#Ref_002eExpr_002eNote">4.11.8 Ref.Expr.Note</a>
<li><a href="#Ref_002eExpr_002eWhile">4.11.9 Ref.Expr.While</a>
<li><a href="#Ref_002eExpr_002eBreak">4.11.10 Ref.Expr.Break</a>
<li><a href="#Ref_002eExpr_002eCont">4.11.11 Ref.Expr.Cont</a>
<li><a href="#Ref_002eExpr_002eFor">4.11.12 Ref.Expr.For</a>
<li><a href="#Ref_002eExpr_002eForeach">4.11.13 Ref.Expr.Foreach</a>
<li><a href="#Ref_002eExpr_002eIf">4.11.14 Ref.Expr.If</a>
<li><a href="#Ref_002eExpr_002eAlt">4.11.15 Ref.Expr.Alt</a>
<ul>
<li><a href="#Ref_002eExpr_002eAlt_002ePat">4.11.15.1 Ref.Expr.Alt.Pat</a>
<li><a href="#Ref_002eExpr_002eAlt_002eType">4.11.15.2 Ref.Expr.Alt.Type</a>
</li></ul>
<li><a href="#Ref_002eExpr_002eProve">4.11.16 Ref.Expr.Prove</a>
<li><a href="#Ref_002eExpr_002eCheck">4.11.17 Ref.Expr.Check</a>
<li><a href="#Ref_002eExpr_002eClaim">4.11.18 Ref.Expr.Claim</a>
<li><a href="#Ref_002eExpr_002eIfCheck">4.11.19 Ref.Expr.IfCheck</a>
<li><a href="#Ref_002eExpr_002eAssert">4.11.20 Ref.Expr.Assert</a>
<li><a href="#Ref_002eExpr_002eAnonObj">4.11.21 Ref.Expr.AnonObj</a>
</li></ul>
<li><a href="#Ref_002eRun">4.12 Ref.Run</a>
<ul>
<li><a href="#Ref_002eRun_002eMem">4.12.1 Ref.Run.Mem</a>
<li><a href="#Ref_002eRun_002eType">4.12.2 Ref.Run.Type</a>
<li><a href="#Ref_002eRun_002eComm">4.12.3 Ref.Run.Comm</a>
<li><a href="#Ref_002eRun_002eLog">4.12.4 Ref.Run.Log</a>
<li><a href="#Ref_002eRun_002eSig">4.12.5 Ref.Run.Sig</a>
</li></ul>
</li></ul>
<li><a name="toc_Index" href="#Index">5 Index</a>
</li></ul>
</div>

<!-- ############################################################ -->
<!-- Disclaimer -->
<!-- ############################################################ -->
<div class="node">
<a name="Disclaimer"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Introduction">Introduction</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Top">Top</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">1 Disclaimer</h2>

<p>To the reader,

   <p>Rust is a work in progress. The language continues to evolve as the design
shifts and is fleshed out in working code. Certain parts work, certain parts
do not, certain parts will be removed or changed.

   <p>This manual is a snapshot written in the present tense. Some features
described do not yet exist in working code. Some may be temporary. It
is a <em>draft</em>, and we ask that you not take anything you read here
as either definitive or final. The manual is to help you get a sense
of the language and its organization, not to serve as a complete
specification. At least not yet.

   <p>If you have suggestions to make, please try to focus them on <em>reductions</em>
to the language: possible features that can be combined or omitted. At this
point, every &ldquo;additive&rdquo; feature we're likely to support is already on the
table. The task ahead involves combining, trimming, and implementing.

<!-- ############################################################ -->
<!-- Introduction -->
<!-- ############################################################ -->
<div class="node">
<a name="Introduction"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Tutorial">Tutorial</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Disclaimer">Disclaimer</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">2 Introduction</h2>

<blockquote>
  We have to fight chaos, and the most effective way of doing that is
  to prevent its emergence.
<div align="right">                                   - Edsger Dijkstra
   </div>
</blockquote>

   <pre class="sp">


</pre>

Rust is a curly-brace, block-structured expression language. It visually
resembles the C language family, but differs significantly in syntactic and
semantic details. Its design is oriented toward concerns of &ldquo;programming in
the large&rdquo;, that is, of creating and maintaining <em>boundaries</em> &ndash; both
abstract and operational &ndash; that preserve large-system <em>integrity</em>,
<em>availability</em> and <em>concurrency</em>.

   <p>It supports a mixture of imperative procedural, concurrent actor,
object-oriented and pure functional styles. Rust also supports generic
programming and metaprogramming, in both static and dynamic styles.

<ul class="menu">
<li><a accesskey="1" href="#Goals">Goals</a>:                       Intentions, motivations. 
<li><a accesskey="2" href="#Sales-Pitch">Sales Pitch</a>:                 A summary for the impatient. 
<li><a accesskey="3" href="#Influences">Influences</a>:                  Relationship to past languages. 
</ul>

<div class="node">
<a name="Goals"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Sales-Pitch">Sales Pitch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">2.1 Goals</h3>

<p>The language design pursues the following goals:

   <pre class="sp">

</pre>
     <ul>
<li>Compile-time error detection and prevention. 
<li>Run-time fault tolerance and containment. 
<li>System building, analysis and maintenance affordances. 
<li>Clarity and precision of expression. 
<li>Implementation simplicity. 
<li>Run-time efficiency. 
<li>High concurrency. 
</ul>

   <pre class="sp">

</pre>

Note that most of these goals are <em>engineering</em> goals, not showcases for
sophisticated language technology. Most of the technology in Rust is
<em>old</em> and has been seen decades earlier in other languages.

   <p>All new languages are developed in a technological context. Rust's goals arise
from the context of writing large programs that interact with the internet &ndash;
both servers and clients &ndash; and are thus much more concerned with
<em>safety</em> and <em>concurrency</em> than older generations of program. Our
experience is that these two forces do not conflict; rather they drive system
design decisions toward extensive use of <em>partitioning</em> and
<em>statelessness</em>. Rust aims to make these a more natural part of writing
programs, within the niche of lower-level, practical, resource-conscious
languages.

<div class="node">
<a name="Sales-Pitch"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Influences">Influences</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Goals">Goals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">2.2 Sales Pitch</h3>

<p>The following comprises a brief &ldquo;sales pitch&rdquo; overview of the salient
features of Rust, relative to other languages.

     <ul>
     <pre class="sp">
     
     </pre>
     <li>No <code>null</code> pointers

     <p>The initialization state of every slot is statically computed as part of the
typestate system (see below), and requires that all slots are initialized
before use. There is no <code>null</code> value; uninitialized slots are
uninitialized and can only be written to, not read.

     <p>The common use for <code>null</code> in other languages &ndash; as a sentinel value &ndash; is
subsumed into the more general facility of disjoint union types. A program
must explicitly model its use of such types.

     <pre class="sp">
     
     </pre>
     <li>Lightweight tasks with no shared values

     <p>Like many <em>actor</em> languages, Rust provides an isolation (and concurrency)
model based on lightweight tasks scheduled by the language runtime. These
tasks are very inexpensive and statically unable to manipulate one another's
local memory. Breaking the rule of task isolation is possible only by calling
external (C/C++) code.

     <p>Inter-task communication is typed, asynchronous, and simplex, based on passing
messages over channels to ports.

     <pre class="sp">
     
     </pre>
     <li>Predictable native code, simple runtime

     <p>The meaning and cost of every operation within a Rust program is intended to
be easy to model for the reader. The code should not &ldquo;surprise&rdquo; the
programmer once it has been compiled.

     <p>Rust compiles to native code. Rust compilation units are large and the
compilation model is designed around multi-file, whole-library or
whole-program optimization. The compiled units are standard loadable objects
(ELF, PE, Mach-O) containing standard debug information (DWARF) and are
compatible with existing, standard low-level tools (disassemblers, debuggers,
profilers, dynamic loaders). The compiled units include custom metadata that
carries full type and version information.

     <p>The Rust runtime library is a small collection of support code for scheduling,
memory management, inter-task communication, reflection and runtime
linkage. This library is written in standard C++ and is quite
straightforward. It presents a simple interface to embeddings. No
research-level virtual machine, JIT or garbage collection technology is
required. It should be relatively easy to adapt a Rust front-end on to many
existing native toolchains.

     <pre class="sp">
     
     </pre>
     <li>Integrated system-construction facility

     <p>The units of compilation of Rust are multi-file amalgamations called
<em>crates</em>. A crate is described by a separate, declarative type of source
file that guides the compilation of the crate, its packaging, its versioning,
and its external dependencies. Crates are also the units of distribution and
loading. Significantly: the dependency graph of crates is <em>acyclic</em> and
<em>anonymous</em>: there is no global namespace for crates, and module-level
recursion cannot cross crate barriers.

     <p>Unlike many languages, individual modules do <em>not</em> carry all the
mechanisms or restrictions of crates. Modules and crates serve different
roles.

     <pre class="sp">
     
     </pre>
     <li>Static control over memory allocation, packing and aliasing.

     <p>Many values in Rust are allocated <em>within</em> their containing stack-frame
or parent structure. Numbers, records, tuples and tags are all allocated this
way. To allocate such values in the heap, they must be explicitly
<em>boxed</em>. A <dfn>box</dfn> is a pointer to a heap allocation that holds another
value, its <em>content</em>. Boxes may be either shared or unique, depending
on which sort of storage management is desired.

     <p>Boxing and unboxing in Rust is explicit, though in some cases (such as
name-component dereferencing) Rust will automatically dereference a
box to access its content. Box values can be passed and assigned
independently, like pointers in C; the difference is that in Rust they always
point to live contents, and are not subject to pointer arithmetic.

     <p>In addition to boxes, Rust supports a kind of pass-by-pointer slot called a
reference. Forming or releasing a reference does not perform reference-count
operations; references can only be formed on values that will provably outlive
the reference. References are not &ldquo;general values&rdquo;, in the sense that they
cannot be independently manipulated. They are a lot like C++'s references,
except that they are safe: the compiler ensures that they always point to live
values.

     <p>In addition, every slot (stack-local allocation or reference) has a static
initialization state that is calculated by the typestate system. This permits
late initialization of slots in functions with complex control-flow, while
still guaranteeing that every use of a slot occurs after it has been
initialized.

     <pre class="sp">
     
     </pre>
     <li>Immutable data by default

     <p>All types in Rust are immutable by default. A field within a type must be
declared as <code>mutable</code> in order to be modified.

     <pre class="sp">
     
     </pre>
     <li>Move semantics and unique pointers

     <p>Rust differentiates copying values from moving them, and permits moving and
swapping values explicitly rather than copying. Moving can be more efficient and,
crucially, represents an indivisible transfer of ownership of a value from its
source to its destination.

     <p>In addition, pointer types in Rust come in several varieties. One important
type of pointer related to move semantics is the <em>unique</em> pointer,
denoted <code>~</code>, which is statically guaranteed to be the only pointer
pointing to its referent at any given time.

     <p>Combining move-semantics and unique pointers, Rust permits a very lightweight
form of inter-task communication: values are sent between tasks by moving, and
only types composed of unique pointers can be sent. This statically ensures
there can never be sharing of data between tasks, while keeping the costs of
transferring data between tasks as cheap as moving a pointer.

     <pre class="sp">
     
     </pre>
     <li>Stack-based iterators

     <p>Rust provides a type of function-like multiple-invocation iterator that is
very efficient: the iterator state lives only on the stack and is tightly
coupled to the loop that invoked it.

     <pre class="sp">
     
     </pre>
     <li>Direct interface to C code

     <p>Rust can load and call many C library functions simply by declaring
them. Calling a C function is an &ldquo;unsafe&rdquo; action, and can only be taken
within a block marked with the <code>unsafe</code> keyword. Every unsafe block
in a Rust compilation unit must be explicitly authorized in the crate file.

     <pre class="sp">
     
     </pre>
     <li>Structural algebraic data types

     <p>The Rust type system is primarily structural, and contains the standard
assortment of useful &ldquo;algebraic&rdquo; type constructors from functional
languages, such as function types, tuples, record types, vectors, and
nominally-tagged disjoint unions. Such values may be <em>pattern-matched</em> in
an <code>alt</code> expression.

     <pre class="sp">
     
     </pre>
     <li>Generic code

     <p>Rust supports a simple form of parametric polymorphism: functions, iterators,
types and objects can be parametrized by other types.

     <pre class="sp">
     
     </pre>
     <li>Argument binding

     <p>Rust provides a mechanism of partially binding arguments to functions,
producing new functions that accept the remaining un-bound arguments. This
mechanism combines some of the features of lexical closures with some of the
features of currying, in a smaller and simpler package.

     <pre class="sp">
     
     </pre>
     <li>Local type inference

     <p>To save some quantity of programmer key-pressing, Rust supports local type
inference: signatures of functions, objects and iterators always require type
annotation, but within the body of a function or iterator many slots can be
declared without a type, and Rust will infer the slot's type from its uses.

     <pre class="sp">
     
     </pre>
     <li>Structural object system

     <p>Rust has a lightweight object system based on structural object types: there
is no &ldquo;class hierarchy&rdquo; nor any concept of inheritance. Method overriding
and object restriction are performed explicitly on object values, which are
little more than order-insensitive records of methods sharing a common private
value.

     <pre class="sp">
     
     </pre>
     <li>Static metaprogramming (syntactic extension)

     <p>Rust supports a system for syntactic extensions that can be loaded into the
compiler, to implement user-defined notations, macros, program-generators and
the like. These notations are <em>marked</em> using a special form of
bracketing, such that a reader unfamiliar with the extension can still parse
the surrounding text by skipping over the bracketed &ldquo;extension text&rdquo;.

     <pre class="sp">
     
     </pre>
     <li>Idempotent failure

     <p>If a task fails due to a signal, or if it evaluates the special <code>fail</code>
expression, it enters the <em>failing</em> state. A failing task unwinds its
control stack, frees all of its owned resources (executing destructors) and
enters the <em>dead</em> state. Failure is idempotent and non-recoverable.

     <pre class="sp">
     
     </pre>
     <li>Supervision hierarchy

     <p>Rust has a system for propagating task-failures, either directly to a
supervisor task, or indirectly by sending a message into a channel.

     <pre class="sp">
     
     </pre>
     <li>Resource types with deterministic destruction

     <p>Rust includes a type constructor for <em>resource</em> types, which have an
associated destructor and cannot be moved in memory. Resources types belong to
the kind of <em>pinned</em> types, and any value that directly contains a
resource is implicitly pinned as well.

     <p>Resources can only contain types from the pinned or unique kinds of type,
which means that unlike finalizers, there is always a deterministic, top-down
order to run the destructors of a resource and its sub-resources.

     <pre class="sp">
     
     </pre>
     <li>Typestate system

     <p>Every storage slot in a Rust frame participates in not only a conventional
structural static type system, describing the interpretation of memory in the
slot, but also a <em>typestate</em> system. The static typestates of a program
describe the set of <em>pure, dynamic predicates</em> that provably hold over
some set of slots, at each point in the program's control-flow graph within
each frame. The static calculation of the typestates of a program is a
function-local dataflow problem, and handles user-defined predicates in a
similar fashion to the way the type system permits user-defined types.

     <p>A short way of thinking of this is: types statically model values,
typestates statically model <em>assertions that hold</em> before and
after statements and expressions.

   </ul>

<div class="node">
<a name="Influences"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Sales-Pitch">Sales Pitch</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Introduction">Introduction</a>

</div>

<h3 class="section">2.3 Influences</h3>

<pre class="sp">


</pre>

<blockquote>
  The essential problem that must be solved in making a fault-tolerant
  software system is therefore that of fault-isolation. Different programmers
  will write different modules, some modules will be correct, others will have
  errors. We do not want the errors in one module to adversely affect the
  behaviour of a module which does not have any errors.

  <div align="right">                                   - Joe Armstrong
   </div>
</blockquote>

   <pre class="sp">


</pre>

<blockquote>
  In our approach, all data is private to some process, and processes can
  only communicate through communications channels. <em>Security</em>, as used
  in this paper, is the property which guarantees that processes in a system
  cannot affect each other except by explicit communication.

   <p>When security is absent, nothing which can be proven about a single module
  in isolation can be guaranteed to hold when that module is embedded in a
  system [...]
<div align="right">                                   - Robert Strom and Shaula Yemini
   </div>
</blockquote>

   <pre class="sp">


</pre>

<blockquote>
  Concurrent and applicative programming complement each other. The
  ability to send messages on channels provides I/O without side effects,
  while the avoidance of shared data helps keep concurrent processes from
  colliding.
       <div align="right">                                   - Rob Pike
   </div>
</blockquote>

   <pre class="sp">


</pre>

   <p>Rust is not a particularly original language. It may however appear unusual by
contemporary standards, as its design elements are drawn from a number of
&ldquo;historical&rdquo; languages that have, with a few exceptions, fallen out of
favour. Five prominent lineages contribute the most:

     <ul>
     <pre class="sp">
     
     </pre>
     <li>The NIL (1981) and Hermes (1990) family. These languages were developed by
Robert Strom, Shaula Yemini, David Bacon and others in their group at IBM
Watson Research Center (Yorktown Heights, NY, USA).

     <pre class="sp">
     
     </pre>
     <li>The Erlang (1987) language, developed by Joe Armstrong, Robert Virding, Claes
Wikstr&ouml;m, Mike Williams and others in their group at the Ericsson Computer
Science Laboratory (&Auml;lvsj&ouml;, Stockholm, Sweden) .

     <pre class="sp">
     
     </pre>
     <li>The Sather (1990) language, developed by Stephen Omohundro, Chu-Cheow Lim,
Heinz Schmidt and others in their group at The International Computer Science
Institute of the University of California, Berkeley (Berkeley, CA, USA).

     <pre class="sp">
     
     </pre>
     <li>The Newsqueak (1988), Alef (1995), and Limbo (1996) family. These languages
were developed by Rob Pike, Phil Winterbottom, Sean Dorward and others in
their group at Bell labs Computing Sciences Reserch Center (Murray Hill, NJ,
USA).

     <pre class="sp">
     
     </pre>
     <li>The Napier (1985) and Napier88 (1988) family. These languages were developed
by Malcolm Atkinson, Ron Morrison and others in their group at the University
of St. Andrews (St. Andrews, Fife, UK). 
</ul>

   <pre class="sp">

</pre>
Additional specific influences can be seen from the following languages:
     <ul>
<li>The structural algebraic types and compilation manager of SML. 
<li>The deterministic destructor system of C++. 
</ul>

<!-- ############################################################ -->
<!-- Tutorial -->
<!-- ############################################################ -->
<div class="node">
<a name="Tutorial"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Reference">Reference</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Introduction">Introduction</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">3 Tutorial</h2>

<p><em>TODO</em>.

<!-- ############################################################ -->
<!-- Reference -->
<!-- ############################################################ -->
<div class="node">
<a name="Reference"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Index">Index</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Tutorial">Tutorial</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">4 Reference</h2>

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eLex">Ref.Lex</a>:                      Lexical structure. 
<li><a accesskey="2" href="#Ref_002ePath">Ref.Path</a>:                     References to items. 
<li><a accesskey="3" href="#Ref_002eGram">Ref.Gram</a>:                     Grammar. 
<li><a accesskey="4" href="#Ref_002eComp">Ref.Comp</a>:                     Compilation and component model. 
<li><a accesskey="5" href="#Ref_002eMem">Ref.Mem</a>:                      Semantic model of memory. 
<li><a accesskey="6" href="#Ref_002eTask">Ref.Task</a>:                     Semantic model of tasks. 
<li><a accesskey="7" href="#Ref_002eItem">Ref.Item</a>:                     The components of a module. 
<li><a accesskey="8" href="#Ref_002eType">Ref.Type</a>:                     The types of values held in memory. 
<li><a accesskey="9" href="#Ref_002eTypestate">Ref.Typestate</a>:                Predicates that hold at points in time. 
<li><a href="#Ref_002eStmt">Ref.Stmt</a>:                     Components of an executable block. 
<li><a href="#Ref_002eExpr">Ref.Expr</a>:                     Units of execution and evaluation. 
<li><a href="#Ref_002eRun">Ref.Run</a>:                      Organization of runtime services. 
</ul>

<div class="node">
<a name="Ref.Lex"></a>
<a name="Ref_002eLex"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002ePath">Ref.Path</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.1 Ref.Lex</h3>

<!-- * Ref.Lex::                     Lexical structure. -->
<p><a name="index-Lexical-structure-1"></a><a name="index-Token-2"></a>
The lexical structure of a Rust source file or crate file is defined in terms
of Unicode character codes and character properties.

   <p>Groups of Unicode character codes and characters are organized into
<em>tokens</em>. Tokens are defined as the longest contiguous sequence of
characters within the same token type (identifier, keyword, literal, symbol),
or interrupted by ignored characters.

   <p>Most tokens in Rust follow rules similar to the C family.

   <p>Most tokens (including whitespace, keywords, operators and structural symbols)
are drawn from the ASCII-compatible range of Unicode. Identifiers are drawn
from Unicode characters specified by the <code>XID_start</code> and
<code>XID_continue</code> rules given by UAX #31<a rel="footnote" href="#fn-1" name="fnd-1"><sup>1</sup></a>. String and character literals may
include the full range of Unicode characters.

   <p><em>TODO: formalize this section much more</em>.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eLex_002eIgnore">Ref.Lex.Ignore</a>:        Ignored characters. 
<li><a accesskey="2" href="#Ref_002eLex_002eIdent">Ref.Lex.Ident</a>:         Identifier tokens. 
<li><a accesskey="3" href="#Ref_002eLex_002eKey">Ref.Lex.Key</a>:           Keyword tokens. 
<li><a accesskey="4" href="#Ref_002eLex_002eRes">Ref.Lex.Res</a>:           Reserved tokens. 
<li><a accesskey="5" href="#Ref_002eLex_002eNum">Ref.Lex.Num</a>:           Numeric tokens. 
<li><a accesskey="6" href="#Ref_002eLex_002eText">Ref.Lex.Text</a>:          String and character tokens. 
<li><a accesskey="7" href="#Ref_002eLex_002eSyntax">Ref.Lex.Syntax</a>:        Syntactic extension tokens. 
<li><a accesskey="8" href="#Ref_002eLex_002eSym">Ref.Lex.Sym</a>:           Special symbol tokens. 
</ul>

<div class="node">
<a name="Ref.Lex.Ignore"></a>
<a name="Ref_002eLex_002eIgnore"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eIdent">Ref.Lex.Ident</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.1 Ref.Lex.Ignore</h4>

<!-- * Ref.Lex.Ignore::            Ignored tokens. -->
<p>Characters considered to be <em>whitespace</em> or <em>comment</em> are ignored,
and are not considered as tokens. They serve only to delimit tokens. Rust is
otherwise a free-form language.

   <p><dfn>Whitespace</dfn> is any of the following Unicode characters: U+0020 (space),
U+0009 (tab, <code>'\t'</code>), U+000A (LF, <code>'\n'</code>), U+000D (CR, <code>'\r'</code>).

   <p><dfn>Comments</dfn> are <em>single-line comments</em> or <em>multi-line comments</em>.

   <p>A <dfn>single-line comment</dfn> is any sequence of Unicode characters beginning
with U+002F U+002F (<code>"//"</code>) and extending to the next U+000A character,
<em>excluding</em> cases in which such a sequence occurs within a string literal
token.

   <p>A <dfn>multi-line comments</dfn> is any sequence of Unicode characters beginning
with U+002F U+002A (<code>"/*"</code>) and ending with U+002A U+002F (<code>"*/"</code>),
<em>excluding</em> cases in which such a sequence occurs within a string literal
token.  Multi-line comments may be nested.

<div class="node">
<a name="Ref.Lex.Ident"></a>
<a name="Ref_002eLex_002eIdent"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eKey">Ref.Lex.Key</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eIgnore">Ref.Lex.Ignore</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.2 Ref.Lex.Ident</h4>

<!-- * Ref.Lex.Ident::             Identifier tokens. -->
<p><a name="index-Identifier-token-3"></a>
Identifiers follow the rules given by Unicode Standard Annex #31, in the form
closed under NFKC normalization, <em>excluding</em> those tokens that are
otherwise defined as keywords or reserved
tokens. See <a href="#Ref_002eLex_002eKey">Ref.Lex.Key</a>. See <a href="#Ref_002eLex_002eRes">Ref.Lex.Res</a>.

   <p>That is: an identifier starts with any character having derived property
<code>XID_Start</code> and continues with zero or more characters having derived
property <code>XID_Continue</code>; and such an identifier is NFKC-normalized during
lexing, such that all subsequent comparison of identifiers is performed on the
NFKC-normalized forms.

   <p><em>TODO: define relationship between Unicode and Rust versions</em>.

   <p><a rel="footnote" href="#fn-2" name="fnd-2"><sup>2</sup></a>

<div class="node">
<a name="Ref.Lex.Key"></a>
<a name="Ref_002eLex_002eKey"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eRes">Ref.Lex.Res</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eIdent">Ref.Lex.Ident</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.3 Ref.Lex.Key</h4>

<!-- * Ref.Lex.Key::                Keyword tokens. -->
<p>The keywords are:
<a name="index-Keywords-4"></a>
   <pre class="sp">


</pre>
   <p><table summary=""><tr align="left"><td valign="top" width="15%"><code>use</code>
</td><td valign="top" width="15%"><code>syntax</code>
</td><td valign="top" width="15%"><code>mutable</code>
</td><td valign="top" width="15%"><code>native</code>
</td><td valign="top" width="15%"><code>unchecked</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>mod</code>
</td><td valign="top" width="15%"><code>import</code>
</td><td valign="top" width="15%"><code>export</code>
</td><td valign="top" width="15%"><code>let</code>
</td><td valign="top" width="15%"><code>const</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>auth</code>
</td><td valign="top" width="15%"><code>unsafe</code>
</td><td valign="top" width="15%"><code>as</code>
</td><td valign="top" width="15%"><code>self</code>
</td><td valign="top" width="15%"><code>log</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>bind</code>
</td><td valign="top" width="15%"><code>type</code>
</td><td valign="top" width="15%"><code>true</code>
</td><td valign="top" width="15%"><code>false</code>
</td><td valign="top" width="15%"><code>any</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>int</code>
</td><td valign="top" width="15%"><code>uint</code>
</td><td valign="top" width="15%"><code>float</code>
</td><td valign="top" width="15%"><code>char</code>
</td><td valign="top" width="15%"><code>bool</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>u8</code>
</td><td valign="top" width="15%"><code>u16</code>
</td><td valign="top" width="15%"><code>u32</code>
</td><td valign="top" width="15%"><code>u64</code>
</td><td valign="top" width="15%"><code>f32</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>i8</code>
</td><td valign="top" width="15%"><code>i16</code>
</td><td valign="top" width="15%"><code>i32</code>
</td><td valign="top" width="15%"><code>i64</code>
</td><td valign="top" width="15%"><code>f64</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>tag</code>
</td><td valign="top" width="15%"><code>vec</code>
</td><td valign="top" width="15%"><code>str</code>
</td><td valign="top" width="15%"><code>with</code>
</td><td valign="top" width="15%"><code>fn</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>iter</code>
</td><td valign="top" width="15%"><code>pure</code>
</td><td valign="top" width="15%"><code>obj</code>
</td><td valign="top" width="15%"><code>resource</code>
</td><td valign="top" width="15%"><code>if</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>else</code>
</td><td valign="top" width="15%"><code>alt</code>
</td><td valign="top" width="15%"><code>in</code>
</td><td valign="top" width="15%"><code>do</code>
</td><td valign="top" width="15%"><code>while</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>break</code>
</td><td valign="top" width="15%"><code>cont</code>
</td><td valign="top" width="15%"><code>note</code>
</td><td valign="top" width="15%"><code>assert</code>
</td><td valign="top" width="15%"><code>claim</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>check</code>
</td><td valign="top" width="15%"><code>prove</code>
</td><td valign="top" width="15%"><code>fail</code>
</td><td valign="top" width="15%"><code>for</code>
</td><td valign="top" width="15%"><code>each</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>ret</code>
</td><td valign="top" width="15%"><code>put</code>
</td><td valign="top" width="15%"><code>be</code>
   <br></td></tr></table>

<div class="node">
<a name="Ref.Lex.Res"></a>
<a name="Ref_002eLex_002eRes"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eNum">Ref.Lex.Num</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eKey">Ref.Lex.Key</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.4 Ref.Lex.Res</h4>

<!-- * Ref.Lex.Res::                Reserved tokens. -->
<p>The reserved tokens are:
<a name="index-Reserved-5"></a>
   <pre class="sp">


</pre>
   <p><table summary=""><tr align="left"><td valign="top" width="15%"><code>f16</code>
</td><td valign="top" width="15%"><code>f80</code>
</td><td valign="top" width="15%"><code>f128</code>
<br></td></tr><tr align="left"><td valign="top" width="15%"><code>m32</code>
</td><td valign="top" width="15%"><code>m64</code>
</td><td valign="top" width="15%"><code>m128</code>
</td><td valign="top" width="15%"><code>dec</code>
   <br></td></tr></table>

   <pre class="sp">


</pre>

At present these tokens have no defined meaning in the Rust language.

   <p>These tokens may correspond, in some current or future implementation,
to additional built-in types for decimal floating-point, extended
binary and interchange floating-point formats, as defined in the IEEE
754-1985 and IEEE 754-2008 specifications.

<div class="node">
<a name="Ref.Lex.Num"></a>
<a name="Ref_002eLex_002eNum"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eText">Ref.Lex.Text</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eRes">Ref.Lex.Res</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.5 Ref.Lex.Num</h4>

<!-- * Ref.Lex.Num::                 Numeric tokens. -->
<p><a name="index-Number-token-6"></a><a name="index-Hex-token-7"></a><a name="index-Decimal-token-8"></a><a name="index-Binary-token-9"></a><a name="index-Floating_002dpoint-token-10"></a>
<!-- FIXME: This discussion isn't quite right since 'f' and 'i' can be used as -->
<!-- suffixes -->

   <p>A <dfn>number literal</dfn> is either an <em>integer literal</em> or a
<em>floating-point literal</em>.

   <pre class="sp">

</pre>
An <dfn>integer literal</dfn> has one of three forms:
     <ol type=1 start=1>
<li>A <dfn>decimal literal</dfn> starts with a <em>decimal digit</em> and continues
with any mixture of <em>decimal digits</em> and <em>underscores</em>.

     <li>A <dfn>hex literal</dfn> starts with the character sequence U+0030
U+0078 (<code>"0x"</code>) and continues as any mixture <em>hex digits</em>
and <em>underscores</em>.

     <li>A <dfn>binary literal</dfn> starts with the character sequence U+0030
U+0062 (<code>"0b"</code>) and continues as any mixture <em>binary digits</em>
and <em>underscores</em>.

        </ol>

   <p>By default, an integer literal is of type <code>int</code>. An integer literal may
be followed (immediately, without any spaces) by a <dfn>integer suffix</dfn>, which
changes the type of the literal. There are three kinds of integer literal
suffix:

     <ol type=1 start=1>
<li>The <code>u</code> suffix gives the literal type <code>uint</code>. 
<li>The <code>g</code> suffix gives the literal type <code>big</code>. 
<li>Each of the signed and unsigned machine types <code>u8</code>, <code>i8</code>,
<code>u16</code>, <code>i16</code>, <code>u32</code>, <code>i32</code>, <code>u64</code> and <code>i64</code>
give the literal the corresponding machine type.
        </ol>

   <pre class="sp">

</pre>
A <dfn>floating-point literal</dfn> has one of two forms:
     <ol type=1 start=1>
<li>Two <em>decimal literals</em> separated by a period
character U+002E ('.'), with an optional <em>exponent</em> trailing after the
second <em>decimal literal</em>. 
<li>A single <em>decimal literal</em> followed by an <em>exponent</em>.
        </ol>

   <p>By default, a floating-point literal is of type <code>float</code>. A floating-point
literal may be followed (immediately, without any spaces) by a
<dfn>floating-point suffix</dfn>, which changes the type of the literal. There are
only two floating-point suffixes: <code>f32</code> and <code>f64</code>. Each of these
gives the floating point literal the associated type, rather than
<code>float</code>.

   <p>A set of suffixes are also reserved to accommodate literal support for
types corresponding to reserved tokens. The reserved suffixes are <code>f16</code>,
<code>f80</code>, <code>f128</code>, <code>m</code>, <code>m32</code>, <code>m64</code> and <code>m128</code>.

   <pre class="sp">

</pre>
A <dfn>hex digit</dfn> is either a <em>decimal digit</em> or else a character in the
ranges U+0061-U+0066 and U+0041-U+0046 (<code>'a'</code>-<code>'f'</code>,
<code>'A'</code>-<code>'F'</code>).

   <p>A <dfn>binary digit</dfn> is either the character U+0030 or U+0031 (<code>'0'</code> or
<code>'1'</code>).

   <p>An <dfn>exponent</dfn> begins with either of the characters U+0065 or U+0045
(<code>'e'</code> or <code>'E'</code>), followed by an optional <em>sign character</em>,
followed by a trailing <em>decimal literal</em>.

   <p>A <dfn>sign character</dfn> is either U+002B or U+002D (<code>'+'</code> or <code>'-'</code>).

   <p>Examples of integer literals of various forms:
<pre class="example">     123;                               // type int
     123u;                              // type uint
     123_u;                             // type uint
     0xff00;                            // type int
     0xffu8;                            // type u8
     0b1111_1111_1001_0000_i32;         // type i32
     0xffff_ffff_ffff_ffff_ffff_ffffg;  // type big
</pre>
   <p>Examples of floating-point literals of various forms:
<pre class="example">     123.0;                             // type float
     0.1;                               // type float
     0.1f32;                            // type f32
     12E+99_f64;                        // type f64
</pre>
   <div class="node">
<a name="Ref.Lex.Text"></a>
<a name="Ref_002eLex_002eText"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eSyntax">Ref.Lex.Syntax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eNum">Ref.Lex.Num</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.6 Ref.Lex.Text</h4>

<!-- * Ref.Lex.Key::                 String and character tokens. -->
<p><a name="index-String-token-11"></a><a name="index-Character-token-12"></a><a name="index-Escape-sequence-13"></a><a name="index-Unicode-14"></a>
A <dfn>character literal</dfn> is a single Unicode character enclosed within two
U+0027 (single-quote) characters, with the exception of U+0027 itself, which
must be <em>escaped</em> by a preceding U+005C character ('\').

   <p>A <dfn>string literal</dfn> is a sequence of any Unicode characters enclosed
within two U+0022 (double-quote) characters, with the exception of U+0022
itself, which must be <em>escaped</em> by a preceding U+005C character
('\').

   <p>Some additional <em>escapes</em> are available in either character or string
literals.  An escape starts with a U+005C ('\') and continues with one
of the following forms:
     <ul>
<li>An <dfn>8-bit codepoint escape</dfn> escape starts with U+0078 ('x') and is
followed by exactly two <dfn>hex digits</dfn>. It denotes the Unicode codepoint
equal to the provided hex value. 
<li>A <dfn>16-bit codepoint escape</dfn> starts with U+0075 ('u') and is followed
 by exactly four <dfn>hex digits</dfn>. It denotes the Unicode codepoint equal to
the provided hex value. 
<li>A <dfn>32-bit codepoint escape</dfn> starts with U+0055 ('U') and is followed
 by exactly eight <dfn>hex digits</dfn>. It denotes the Unicode codepoint equal to
the provided hex value. 
<li>A <dfn>whitespace escape</dfn> is one of the characters U+006E, U+0072, or
U+0074, denoting the unicode values U+000A (LF), U+000D (CR) or U+0009 (HT)
respectively. 
<li>The <dfn>backslash escape</dfn> is the character U+005C ('\') which must be
escaped in order to denote <em>itself</em>. 
</ul>

<div class="node">
<a name="Ref.Lex.Syntax"></a>
<a name="Ref_002eLex_002eSyntax"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eLex_002eSym">Ref.Lex.Sym</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eText">Ref.Lex.Text</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.7 Ref.Lex.Syntax</h4>

<!-- * Ref.Lex.Syntax::              Syntactic extension tokens. -->
<p>Syntactic extensions are marked with the <em>pound</em> sigil U+0023 (<code>#</code>),
followed by an identifier, one of <code>fmt</code>, <code>env</code>,
<code>concat_idents</code>, <code>ident_to_str</code>, <code>log_syntax</code>, <code>macro</code>, or
the name of a user-defined macro. This is followed by a vector literal. (Its
value will be interpreted syntactically; in particular, it need not be
well-typed.)

   <p><em>TODO: formalize those terms more</em>.

<div class="node">
<a name="Ref.Lex.Sym"></a>
<a name="Ref_002eLex_002eSym"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex_002eSyntax">Ref.Lex.Syntax</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eLex">Ref.Lex</a>

</div>

<h4 class="subsection">4.1.8 Ref.Lex.Sym</h4>

<!-- * Ref.Lex.Sym::                 Special symbol tokens. -->
<p><a name="index-Symbol-15"></a><a name="index-Operator-16"></a>
The special symbols are:

   <pre class="sp">


</pre>
   <p><table summary="">
<tr align="left"><td valign="top" width="10%"><code>@</code>
</td><td valign="top" width="10%"><code>_</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>#</code>
</td><td valign="top" width="10%"><code>:</code>
</td><td valign="top" width="10%"><code>.</code>
</td><td valign="top" width="10%"><code>;</code>
</td><td valign="top" width="10%"><code>,</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>[</code>
</td><td valign="top" width="10%"><code>]</code>
</td><td valign="top" width="10%"><code>{</code>
</td><td valign="top" width="10%"><code>}</code>
</td><td valign="top" width="10%"><code>(</code>
</td><td valign="top" width="10%"><code>)</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>=</code>
</td><td valign="top" width="10%"><code>&lt;-</code>
</td><td valign="top" width="10%"><code>&lt;-&gt;</code>
</td><td valign="top" width="10%"><code>-&gt;</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>+</code>
</td><td valign="top" width="10%"><code>++</code>
</td><td valign="top" width="10%"><code>+=</code>
</td><td valign="top" width="10%"><code>-</code>
</td><td valign="top" width="10%"><code>--</code>
</td><td valign="top" width="10%"><code>-=</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>*</code>
</td><td valign="top" width="10%"><code>/</code>
</td><td valign="top" width="10%"><code>%</code>
</td><td valign="top" width="10%"><code>*=</code>
</td><td valign="top" width="10%"><code>/=</code>
</td><td valign="top" width="10%"><code>%=</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>&amp;</code>
</td><td valign="top" width="10%"><code>|</code>
</td><td valign="top" width="10%"><code>!</code>
</td><td valign="top" width="10%"><code>~</code>
</td><td valign="top" width="10%"><code>^</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>&amp;=</code>
</td><td valign="top" width="10%"><code>|=</code>
</td><td valign="top" width="10%"><code>^=</code>
</td><td valign="top" width="10%"><code>!=</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>&gt;&gt;</code>
</td><td valign="top" width="10%"><code>&gt;&gt;&gt;</code>
</td><td valign="top" width="10%"><code>&lt;&lt;</code>
</td><td valign="top" width="10%"><code>&lt;&lt;=</code>
</td><td valign="top" width="10%"><code>&gt;&gt;=</code>
</td><td valign="top" width="10%"><code>&gt;&gt;&gt;=</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>&lt;</code>
</td><td valign="top" width="10%"><code>&lt;=</code>
</td><td valign="top" width="10%"><code>==</code>
</td><td valign="top" width="10%"><code>&gt;=</code>
</td><td valign="top" width="10%"><code>&gt;</code>
<br></td></tr><tr align="left"><td valign="top" width="10%"><code>&amp;&amp;</code>
</td><td valign="top" width="10%"><code>||</code>
   <br></td></tr></table>

<div class="node">
<a name="Ref.Path"></a>
<a name="Ref_002ePath"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eGram">Ref.Gram</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eLex">Ref.Lex</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.2 Ref.Path</h3>

<!-- * Ref.Path::               References to items. -->
<p><a name="index-Names-of-items-or-slots-17"></a><a name="index-Path-name-18"></a><a name="index-Type-parameters-19"></a>
A <dfn>path</dfn> is a sequence of one or more path components separated by a
namespace qualifier (<code>::</code>). If a path consists of only one component, it
may refer to either an item or a slot in a local control
scope. See <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a>. See <a href="#Ref_002eItem">Ref.Item</a>. If a path has multiple
components, it refers to an item.

   <p>Every item has a <em>canonical path</em> within its crate, but the path naming
an item is only meaningful within a given crate. There is no global namespace
across crates; an item's canonical path merely identifies it within the
crate. See <a href="#Ref_002eComp_002eCrate">Ref.Comp.Crate</a>.

   <p>Path components are usually identifiers. See <a href="#Ref_002eLex_002eIdent">Ref.Lex.Ident</a>. The last
component of a path may also have trailing explicit type arguments.

   <p>Two examples of simple paths consisting of only identifier components:
<pre class="example">     x;
     x::y::z;
</pre>
   <p>In most contexts, the Rust grammar accepts a general <em>path</em>, but
subsequent passes pay restrict paths occurring in various contexts to refer to
slots or items, depending on the semantics of the occurrence. In other words:
in some contexts a slot is required (for example, on the left hand side of the
copy operator, see <a href="#Ref_002eExpr_002eCopy">Ref.Expr.Copy</a>) and in other contexts an item is
required (for example, as a type parameter, see <a href="#Ref_002eItem">Ref.Item</a>). In no case is
the grammar made ambiguous by accepting a general path and interpreting the
reference in later passes. See <a href="#Ref_002eGram">Ref.Gram</a>.

   <p>An example of a path with type parameters:
<pre class="example">     m::map&lt;int,str&gt;;
</pre>
   <div class="node">
<a name="Ref.Gram"></a>
<a name="Ref_002eGram"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eComp">Ref.Comp</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002ePath">Ref.Path</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.3 Ref.Gram</h3>

<!-- * Ref.Gram::                    Grammar. -->
<p><em>TODO: mostly LL(1), it reads like C++, Alef and bits of Napier;
formalize here</em>.

<div class="node">
<a name="Ref.Comp"></a>
<a name="Ref_002eComp"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eMem">Ref.Mem</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eGram">Ref.Gram</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.4 Ref.Comp</h3>

<!-- * Ref.Comp::                    Compilation and component model. -->
<p><a name="index-Compilation-model-20"></a>
Rust is a <em>compiled</em> language. Its semantics are divided along a
<em>phase distinction</em> between compile-time and run-time. Those semantic
rules that have a <em>static interpretation</em> govern the success or failure
of compilation. A program that fails to compile due to violation of a
compile-time rule has no defined semantics at run-time; the compiler should
halt with an error report, and produce no executable artifact.

   <p>The compilation model centres on artifacts called <em>crates</em>. Each
compilation is directed towards a single crate in source form, and if
successful produces a single crate in executable form.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eComp_002eCrate">Ref.Comp.Crate</a>:               Units of compilation and linking. 
<li><a accesskey="2" href="#Ref_002eComp_002eAttr">Ref.Comp.Attr</a>:                Attributes of crates, modules and items. 
<li><a accesskey="3" href="#Ref_002eComp_002eSyntax">Ref.Comp.Syntax</a>:              Syntax extensions. 
</ul>

<div class="node">
<a name="Ref.Comp.Crate"></a>
<a name="Ref_002eComp_002eCrate"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eComp_002eAttr">Ref.Comp.Attr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eComp">Ref.Comp</a>

</div>

<h4 class="subsection">4.4.1 Ref.Comp.Crate</h4>

<!-- * Ref.Comp.Crate::              Units of compilation and linking. -->
<p><a name="index-Crate-21"></a>
A <dfn>crate</dfn> is a unit of compilation and linking, as well as versioning,
distribution and runtime loading. Crates are defined by <em>crate source
files</em>, which are a type of source file written in a special declarative
language: <em>crate language</em>.<a rel="footnote" href="#fn-3" name="fnd-3"><sup>3</sup></a> A crate source file describes:

     <ul>
<li>Metadata about the crate, such as author, name, version, and copyright. 
<li>The source-file and directory modules that make up the crate. 
<li>Any external crates or native modules that the crate imports to its top level. 
<li>The organization of the crate's internal namespace. 
<li>The set of names exported from the crate. 
</ul>

   <p>A single crate source file may describe the compilation of a large number of
Rust source files; it is compiled in its entirety, as a single indivisible
unit. The compilation phase attempts to transform a single crate source file,
and its referenced contents, into a single compiled crate. Crate source files
and compiled crates have a 1:1 relationship.

   <p>The syntactic form of a crate is a sequence of <em>directives</em>, some of
which have nested sub-directives.

   <p>A crate defines an implicit top-level anonymous module: within this module,
all members of the crate have canonical path names. See <a href="#Ref_002ePath">Ref.Path</a>. The
<code>mod</code> directives within a crate file specify sub-modules to include in
the crate: these are either directory modules, corresponding to directories in
the filesystem of the compilation environment, or file modules, corresponding
to Rust source files. The names given to such modules in <code>mod</code> directives
become prefixes of the paths of items defined within any included Rust source
files.

   <p>The <code>use</code> directives within the crate specify <em>other crates</em> to scan
for, locate, import into the crate's module namespace during compilation, and
link against at runtime. Use directives may also occur independently in rust
source files. These directives may specify loose or tight &ldquo;matching
criteria&rdquo; for imported crates, depending on the preferences of the crate
developer. In the simplest case, a <code>use</code> directive may only specify a
symbolic name and leave the task of locating and binding an appropriate crate
to a compile-time heuristic. In a more controlled case, a <code>use</code> directive
may specify any metadata as matching criteria, such as a URI, an author name
or version number, a checksum or even a cryptographic signature, in order to
select an an appropriate imported crate. See <a href="#Ref_002eComp_002eAttr">Ref.Comp.Attr</a>.

   <p>The compiled form of a crate is a loadable and executable object file full of
machine code, in a standard loadable operating-system format such as ELF, PE
or Mach-O. The loadable object contains metadata, describing:
     <ul>
<li>Metadata required for type reflection. 
<li>The publicly exported module structure of the crate. 
<li>Any metadata about the crate, defined by attributes. 
<li>The crates to dynamically link with at run-time, with matching criteria
derived from the same <code>use</code> directives that guided compile-time imports. 
</ul>

<!-- This might come along sometime in the future. -->
<!-- The @code{syntax} directives of a crate are similar to the @code{use} -->
<!-- directives, except they govern the syntax extension namespace (accessed -->
<!-- through the syntax-extension sigil @code{#}, @pxref{Ref.Comp.Syntax}) -->
<!-- available only at compile time. A @code{syntax} directive also makes its -->
<!-- extension available to all subsequent directives in the crate file. -->
   <p>An example of a crate:

<pre class="example">     // Linkage attributes
     #[ link(name = "projx"
             vers = "2.5",
             uuid = "9cccc5d5-aceb-4af5-8285-811211826b82") ];
     
     // Additional metadata attributes
     #[ desc = "Project X",
        license = "BSD" ];
        author = "Jane Doe" ];
     
     // Import a module.
     use std (ver = "1.0");
     
     // Define some modules.
     mod foo = "foo.rs";
     mod bar {
         mod quux = "quux.rs";
     }
</pre>
   <div class="node">
<a name="Ref.Comp.Attr"></a>
<a name="Ref_002eComp_002eAttr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eComp_002eSyntax">Ref.Comp.Syntax</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eComp_002eCrate">Ref.Comp.Crate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eComp">Ref.Comp</a>

</div>

<h4 class="subsection">4.4.2 Ref.Comp.Attr</h4>

<p><a name="index-Attributes-22"></a>
Static entities in Rust &ndash; crates, modules and items &ndash; may have attributes
applied to them.<a rel="footnote" href="#fn-4" name="fnd-4"><sup>4</sup></a> An attribute is a general, free-form piece of metadata that is
interpreted according to name, convention, and language and compiler version. 
Attributes may appear as any of:
     <ul>
<li>A single identifier, the attribute name
<li>An identifier followed by the equals sign '=' and a literal, providing a key/value pair
<li>An identifier followed by a parenthesized list of sub-attribute arguments
</ul>

   <p>Attributes are applied to an entity by placing them within a hash-list
(<code>#[...]</code>) as either a prefix to the entity or as a semicolon-delimited
declaration within the entity body.

   <p>An example of attributes:

<pre class="example">     // A function marked as a unit test
     #[test]
     fn test_foo() {
       ...
     }
     
     // General metadata applied to the enclosing module or crate.
     #[license = "BSD"];
     
     // A conditionally-compiled module
     #[cfg(target_os="linux")]
     module bar {
       ...
     }
     
</pre>
   <p>In future versions of Rust, user-provided extensions to the compiler will be able
to interpret attributes. When this facility is provided, a distinction will be
made between language-reserved and user-available attributes.

   <p>At present, only the Rust compiler interprets attributes, so all attribute
names are effectively reserved. Some significant attributes include:

     <ul>
<li>The <code>cfg</code> attribute, for conditional-compilation by build-configuration
<li>The <code>link</code> attribute, describing linkage metadata for a crate
<li>The <code>test</code> attribute, for marking functions as unit tests. 
</ul>

   <p>Other attributes may be added or removed during development of the language.

<div class="node">
<a name="Ref.Comp.Syntax"></a>
<a name="Ref_002eComp_002eSyntax"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eComp_002eAttr">Ref.Comp.Attr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eComp">Ref.Comp</a>

</div>

<h4 class="subsection">4.4.3 Ref.Comp.Syntax</h4>

<!-- * Ref.Comp.Syntax::        Syntax extension. -->
<p><a name="index-Syntax-extension-23"></a>
Rust provides a notation for <dfn>syntax extension</dfn>. The notation for invoking
a syntax extension is a marked syntactic form that can appear as an expression
in the body of a Rust program. See <a href="#Ref_002eLex_002eSyntax">Ref.Lex.Syntax</a>.

   <p>After parsing, a syntax-extension incovation is expanded into a Rust
expression. The name of the extension determines the translation performed. In
future versions of Rust, user-provided syntax extensions aside from macros
will be provided via external crates.

   <p>At present, only a set of built-in syntax extensions, as well as macros
introduced inline in source code using the <code>macro</code> extension, may be
used. The current built-in syntax extensions are:

     <ul>
<li><code>fmt</code> expands into code to produce a formatted string, similar to
      <code>printf</code> from C. 
<li><code>env</code> expands into a string literal containing the value of that
      environment variable at compile-time. 
<li><code>concat_idents</code> expands into an identifier which is the
      concatenation of its arguments. 
<li><code>ident_to_str</code> expands into a string literal containing the name of
      its argument (which must be a literal). 
<li><code>log_syntax</code> causes the compiler to pretty-print its arguments. 
</ul>

   <p>Finally, <code>macro</code> is used to define a new macro. A macro can abstract over
second-class Rust concepts that are present in syntax. The arguments to
<code>macro</code> are a bracketed list of pairs (two-element lists). The pairs
consist of an invocation and the syntax to expand into. An example:

<pre class="example">     #macro[[#apply[fn, [args, ...]], fn(args, ...)]];
</pre>
   <p>In this case, the invocation <code>#apply[sum, 5, 8, 6]</code> expands to
<code>sum(5,8,6)</code>. If <code>...</code> follows an expression (which need not be as
simple as a single identifier) in the input syntax, the matcher will expect an
arbitrary number of occurences of the thing preceeding it, and bind syntax to
the identifiers it contains. If it follows an expression in the output syntax,
it will transcribe that expression repeatedly, according to the identifiers
(bound to syntax) that it contains.

   <p>The behavior of <code>...</code> is known as Macro By Example. It allows you to
write a macro with arbitrary repetition by specifying only one case of that
repetition, and following it by <code>...</code>, both where the repeated input is
matched, and where the repeated output must be transcribed. A more
sophisticated example:

<pre class="example">     #macro[#zip_literals[[x, ...], [y, ...]],
            [[x, y], ...]];
     #macro[#unzip_literals[[x, y], ...],
            [[x, ...], [y, ...]]];
</pre>
   <p>In this case, <code>#zip_literals[[1,2,3], [1,2,3]]</code> expands to
<code>[[1,1],[2,2],[3,3]]</code>, and <code>#unzip_literals[[1,1], [2,2], [3,3]]</code>
expands to <code>[[1,2,3],[1,2,3]]</code>.

   <p>Macro expansion takes place outside-in: that is,
<code>#unzip_literals[#zip_literals[[1,2,3],[1,2,3]]]</code> will fail because
<code>unzip_literals</code> expects a list, not a macro invocation, as an
argument.

   <p>The macro system currently has some limitations. It's not possible to
destructure anything other than vector literals (therefore, the arguments to
complicated macros will tend to be an ocean of square brackets). Macro
invocations and <code>...</code> can only appear in expression positions. Finally,
macro expansion is currently unhygienic. That is, name collisions between
macro-generated and user-written code can cause unintentional capture.

<div class="node">
<a name="Ref.Mem"></a>
<a name="Ref_002eMem"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask">Ref.Task</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eComp">Ref.Comp</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.5 Ref.Mem</h3>

<!-- * Ref.Mem::                     Semantic model of memory. -->
<p><a name="index-Memory-model-24"></a><a name="index-Box-25"></a><a name="index-Slot-26"></a>
A Rust task's memory consists of a static set of <em>items</em>, a set of tasks
each with its own <em>stack</em>, and a <em>heap</em>. Immutable portions of the
heap may be shared between tasks, mutable portions may not.

   <p>Allocations in the stack consist of <em>slots</em>, and allocations in the heap
consist of <em>boxes</em>.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a>:                Memory allocation model. 
<li><a accesskey="2" href="#Ref_002eMem_002eOwn">Ref.Mem.Own</a>:                  Memory ownership model. 
<li><a accesskey="3" href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a>:                 Stack memory model. 
<li><a accesskey="4" href="#Ref_002eMem_002eBox">Ref.Mem.Box</a>:                  Heap memory model. 
</ul>

<div class="node">
<a name="Ref.Mem.Alloc"></a>
<a name="Ref_002eMem_002eAlloc"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eMem_002eOwn">Ref.Mem.Own</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eMem">Ref.Mem</a>

</div>

<h4 class="subsection">4.5.1 Ref.Mem.Alloc</h4>

<!-- * Ref.Mem.Alloc::               Memory allocation model. -->
<p><a name="index-Item-27"></a><a name="index-Stack-28"></a><a name="index-Heap-29"></a><a name="index-Shared-box-30"></a><a name="index-Task_002dlocal-box-31"></a>
The <dfn>items</dfn> of a program are those functions, iterators, objects, modules
and types that have their value calculated at compile-time and stored uniquely
in the memory image of the rust process. Items are neither dynamically
allocated nor freed.

   <p>A task's <dfn>stack</dfn> consists of activation frames automatically allocated on
entry to each function as the task executes. A stack allocation is reclaimed
when control leaves the frame containing it.

   <p>The <dfn>heap</dfn> is a general term that describes two separate sets of boxes:
shared boxes &ndash; which may be subject to garbage collection &ndash; and unique
boxes.  The lifetime of an allocation in the heap depends on the lifetime of
the box values pointing to it. Since box values may themselves be passed in
and out of frames, or stored in the heap, heap allocations may outlive the
frame they are allocated within.

<div class="node">
<a name="Ref.Mem.Own"></a>
<a name="Ref_002eMem_002eOwn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eMem">Ref.Mem</a>

</div>

<h4 class="subsection">4.5.2 Ref.Mem.Own</h4>

<!-- * Ref.Mem.Own::                 Memory ownership model. -->
<p><a name="index-Ownership-32"></a>
A task owns all memory it can <em>safely</em> reach through local variables,
shared or unique boxes, and/or references. Sharing memory between tasks can
only be accomplished using <em>unsafe</em> constructs, such as raw pointer
operations or calling C code.

   <p>When a task sends a value of <em>unique</em> kind over a channel, it loses
ownership of the value sent and can no longer refer to it. This is statically
guaranteed by the combined use of &ldquo;move semantics&rdquo; and unique kinds, within
the communication system.

   <p>When a stack frame is exited, its local allocations are all released, and its
references to boxes (both shared and owned) are dropped.

   <p>A shared box may (in the case of a recursive, mutable shared type) be cyclic;
in this case the release of memory inside the shared structure may be deferred
until task-local garbage collection can reclaim it. Code can ensure no such
delayed deallocation occurs by restricting itself to unique boxes and similar
unshared kinds of data.

   <p>When a task finishes, its stack is necessarily empty and it therefore has no
references to any boxes; the remainder of its heap is immediately freed.

<div class="node">
<a name="Ref.Mem.Slot"></a>
<a name="Ref_002eMem_002eSlot"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eMem_002eBox">Ref.Mem.Box</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eMem_002eOwn">Ref.Mem.Own</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eMem">Ref.Mem</a>

</div>

<h4 class="subsection">4.5.3 Ref.Mem.Slot</h4>

<!-- * Ref.Mem.Slot::                Stack memory model. -->
<p><a name="index-Stack-33"></a><a name="index-Slot-34"></a><a name="index-Local-slot-35"></a><a name="index-Reference-slot-36"></a>
A task's stack contains slots.

   <p>A <dfn>slot</dfn> is a component of a stack frame. A slot is either <em>local</em> or
an <em>alias</em>.

   <p>A <dfn>local</dfn> slot (or <em>stack-local</em> allocation) holds a value directly,
allocated within the stack's memory. The value is a part of the stack frame.

   <p>A <dfn>reference</dfn> references a value outside the frame. It may refer to a
value allocated in another frame <em>or</em> a boxed value in the heap. The
reference-formation rules ensure that the referent will outlive the reference.

   <p>Local slots are always implicitly mutable.

   <p>Local slots are not initialized when allocated; the entire frame worth of
local slots are allocated at once, on frame-entry, in an uninitialized
state. Subsequent statements within a function may or may not initialize the
local slots. Local slots can be used only after they have been initialized;
this condition is guaranteed by the typestate system.

   <p>References are created for function arguments. If the compiler can not prove
that the referred-to value will outlive the reference, it will try to set
aside a copy of that value to refer to. If this is not sematically safe (for
example, if the referred-to value contains mutable fields), it will reject the
program. If the compiler deems copying the value expensive, it will warn.

   <p>A function can be declared to take an argument by mutable reference. This
allows the function to write to the slot that the reference refers to.

   <p>An example function that accepts an value by mutable reference:
<pre class="example">     fn incr(&amp;i: int) {
         i = i + 1;
     }
</pre>
   <div class="node">
<a name="Ref.Mem.Box"></a>
<a name="Ref_002eMem_002eBox"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eMem">Ref.Mem</a>

</div>

<h4 class="subsection">4.5.4 Ref.Mem.Box</h4>

<!-- * Ref.Mem.Box::                 Heap memory model. -->
<p><a name="index-Box-37"></a><a name="index-Dereference-operator-38"></a>
A <dfn>box</dfn> is a reference to a heap allocation holding another value. There
are two kinds of boxes: <em>shared boxes</em> and <em>unique boxes</em>.

   <p>A <dfn>shared box</dfn> type or value is constructed by the prefix <em>at</em> sigil <code>@</code>.

   <p>A <dfn>unique box</dfn> type or value is constructed by the prefix <em>tilde</em> sigil <code>~</code>.

   <p>Multiple shared box values can point to the same heap allocation; copying a
shared box value makes a shallow copy of the pointer (optionally incrementing
a reference count, if the shared box is implemented through
reference-counting).

   <p>Unique box values exist in 1:1 correspondence with their heap allocation;
copying a unique box value makes a deep copy of the heap allocation and
produces a pointer to the new allocation.

   <p>An example of constructing one shared box type and value, and one unique box type and value:
<pre class="example">     let x: @int = @10;
     let x: ~int = ~10;
</pre>
   <p>Some operations implicitly dereference boxes. Examples of such <dfn>implicit
dereference</dfn> operations are:
     <ul>
<li>arithmetic operators (<code>x + y - z</code>)
<li>field selection (<code>x.y.z</code>)
</ul>

   <p>An example of an implicit-dereference operation performed on box values:
<pre class="example">     let x: @int = @10;
     let y: @int = @12;
     assert (x + y == 22);
</pre>
   <p>Other operations act on box values as single-word-sized address values. For
these operations, to access the value held in the box requires an explicit
dereference of the box value. Explicitly dereferencing a box is indicated with
the unary <em>star</em> operator <code>*</code>. Examples of such <dfn>explicit
dereference</dfn> operations are:
     <ul>
<li>copying box values (<code>x = y</code>)
<li>passing box values to functions (<code>f(x,y)</code>)
</ul>

   <p>An example of an explicit-dereference operation performed on box values:
<pre class="example">     fn takes_boxed(b: @int) {
     }
     
     fn takes_unboxed(b: int) {
     }
     
     fn main() {
         let x: @int = @10;
         takes_boxed(x);
         takes_unboxed(*x);
     }
</pre>
   <div class="node">
<a name="Ref.Task"></a>
<a name="Ref_002eTask"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem">Ref.Item</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eMem">Ref.Mem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.6 Ref.Task</h3>

<!-- * Ref.Task::                    Semantic model of tasks. -->
<p><a name="index-Task-39"></a><a name="index-Process-40"></a>
An executing Rust program consists of a tree of tasks. A Rust <dfn>task</dfn>
consists of an entry function, a stack, a set of outgoing communication
channels and incoming communication ports, and ownership of some portion of
the heap of a single operating-system process.

   <p>Multiple Rust tasks may coexist in a single operating-system
process. Execution of multiple Rust tasks in a single operating-system process
may be either truly concurrent or interleaved by the runtime scheduler. Rust
tasks are lightweight: each consumes less memory than an operating-system
process, and switching between Rust tasks is faster than switching between
operating-system processes.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eTask_002eComm">Ref.Task.Comm</a>:                Inter-task communication. 
<li><a accesskey="2" href="#Ref_002eTask_002eLife">Ref.Task.Life</a>:                Task lifecycle and state transitions. 
<li><a accesskey="3" href="#Ref_002eTask_002eSched">Ref.Task.Sched</a>:               Task scheduling model. 
<li><a accesskey="4" href="#Ref_002eTask_002eSpawn">Ref.Task.Spawn</a>:               Library interface for making new tasks. 
<li><a accesskey="5" href="#Ref_002eTask_002eSend">Ref.Task.Send</a>:                Library interface for sending messages. 
<li><a accesskey="6" href="#Ref_002eTask_002eRecv">Ref.Task.Recv</a>:                Library interface for receiving messages. 
</ul>

<div class="node">
<a name="Ref.Task.Comm"></a>
<a name="Ref_002eTask_002eComm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask_002eLife">Ref.Task.Life</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.1 Ref.Task.Comm</h4>

<!-- * Ref.Task.Comm::               Inter-task communication. -->
<p><a name="index-Communication-41"></a><a name="index-Port-42"></a><a name="index-Channel-43"></a><a name="index-Message-passing-44"></a><a name="index-Send-expression-45"></a><a name="index-Receive-expression-46"></a>
With the exception of <em>unsafe</em> blocks, Rust tasks are isolated from
interfering with one another's memory directly. Instead of manipulating shared
storage, Rust tasks communicate with one another using a typed, asynchronous,
simplex message-passing system.

   <p>A <dfn>port</dfn> is a communication endpoint that can <em>receive</em>
messages. Ports receive messages from channels.

   <p>A <dfn>channel</dfn> is a communication endpoint that can <em>send</em>
messages. Channels send messages to ports.

   <p>Each port is implicitly boxed and mutable; as such a port has a unique
per-task identity and cannot be replicated or transmitted. If a port value is
copied, both copies refer to the <em>same</em> port. New ports can be
constructed dynamically and stored in data structures.

   <p>Each channel is bound to a port when the channel is constructed, so the
destination port for a channel must exist before the channel itself. A channel
cannot be rebound to a different port from the one it was constructed with.

   <p>Channels are weak: a channel does not keep the port it is bound to
alive. Ports are owned by their allocating task and cannot be sent over
channels; if a task dies its ports die with it, and all channels bound to
those ports no longer function. Messages sent to a channel connected to a dead
port will be dropped.

   <p>Channels are immutable types with meaning known to the runtime; channels can
be sent over channels.

   <p>Many channels can be bound to the same port, but each channel is bound to a
single port. In other words, channels and ports exist in an N:1 relationship,
N channels to 1 port. <a rel="footnote" href="#fn-5" name="fnd-5"><sup>5</sup></a>

   <p>Each port and channel can carry only one type of message. The message type is
encoded as a parameter of the channel or port type. The message type of a
channel is equal to the message type of the port it is bound to. The types of
messages must be of <em>unique</em> kind.

   <p>Messages are generally sent asynchronously, with optional rate-limiting on the
transmit side. A channel contains a message queue and asynchronously sending a
message merely inserts it into the sending channel's queue; message receipt is
the responsibility of the receiving task.

   <p>Messages are sent on channels and received on ports using standard library
functions.

<div class="node">
<a name="Ref.Task.Life"></a>
<a name="Ref_002eTask_002eLife"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask_002eSched">Ref.Task.Sched</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask_002eComm">Ref.Task.Comm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.2 Ref.Task.Life</h4>

<!-- * Ref.Task.Life::               Task lifecycle and state transitions. -->
<p><a name="index-Lifecycle-of-task-47"></a><a name="index-Scheduling-48"></a><a name="index-Running_002c-task-state-49"></a><a name="index-Blocked_002c-task-state-50"></a><a name="index-Failing_002c-task-state-51"></a><a name="index-Dead_002c-task-state-52"></a><a name="index-Soft-failure-53"></a><a name="index-Hard-failure-54"></a>
The <dfn>lifecycle</dfn> of a task consists of a finite set of states and events
that cause transitions between the states. The lifecycle states of a task are:

     <ul>
<li>running
<li>blocked
<li>failing
<li>dead
</ul>

   <p>A task begins its lifecycle &ndash; once it has been spawned &ndash; in the
<em>running</em> state. In this state it executes the statements of its entry
function, and any functions called by the entry function.

   <p>A task may transition from the <em>running</em> state to the <em>blocked</em>
state any time it evaluates a communication expression on a port or channel that
cannot be immediately completed.  When the communication expression can be
completed &ndash; when a message arrives at a sender, or a queue drains
sufficiently to complete a semi-synchronous send &ndash; then the blocked task will
unblock and transition back to <em>running</em>.

   <p>A task may transition to the <em>failing</em> state at any time, due to an
un-trapped signal or the evaluation of a <code>fail</code> expression. Once
<em>failing</em>, a task unwinds its stack and transitions to the <em>dead</em>
state. Unwinding the stack of a task is done by the task itself, on its own
control stack. If a value with a destructor is freed during unwinding, the
code for the destructor is run, also on the task's control
stack. Running the destructor code causes a temporary transition to a
<em>running</em> state, and allows the destructor code to cause any
subsequent state transitions.  The original task of unwinding and
failing thereby may suspend temporarily, and may involve (recursive)
unwinding of the stack of a failed destructor. Nonetheless, the
outermost unwinding activity will continue until the stack is unwound
and the task transitions to the <em>dead</em> state. There is no way to
&ldquo;recover&rdquo; from task failure.  Once a task has temporarily suspended
its unwinding in the <em>failing</em> state, failure occurring from
within this destructor results in <em>hard</em> failure.  The unwinding
procedure of hard failure frees resources but does not execute
destructors.  The original (soft) failure is still resumed at the
point where it was temporarily suspended.

   <p>A task in the <em>dead</em> state cannot transition to other states; it exists
only to have its termination status inspected by other tasks, and/or to await
reclamation when the last reference to it drops.

<div class="node">
<a name="Ref.Task.Sched"></a>
<a name="Ref_002eTask_002eSched"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask_002eSpawn">Ref.Task.Spawn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask_002eLife">Ref.Task.Life</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.3 Ref.Task.Sched</h4>

<!-- * Ref.Task.Sched::              Task scheduling model. -->
<p><a name="index-Scheduling-55"></a><a name="index-Preemption-56"></a><a name="index-Yielding-control-57"></a>
The currently scheduled task is given a finite <em>time slice</em> in which to
execute, after which it is <em>descheduled</em> at a loop-edge or similar
preemption point, and another task within is scheduled, pseudo-randomly.

   <p>An executing task can <code>yield</code> control at any time, which deschedules it
immediately. Entering any other non-executing state (blocked, dead) similarly
deschedules the task.

<div class="node">
<a name="Ref.Task.Spawn"></a>
<a name="Ref_002eTask_002eSpawn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask_002eSend">Ref.Task.Send</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask_002eSched">Ref.Task.Sched</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.4 Ref.Task.Spawn</h4>

<!-- * Ref.Task.Spawn::               Calls for creating new tasks. -->
<p><a name="index-Spawn-expression-58"></a>
A call to <code>std::task::spawn</code>, passing a 0-argument function as its single
argument, causes the runtime to construct a new task executing the passed
function. The passed function is referred to as the <dfn>entry function</dfn> for
the spawned task, and any captured environment is carries is moved from the
spawning task to the spawned task before the spawned task begins execution.

   <p>The result of a <code>spawn</code> call is a <code>std::task::task</code> value.

   <p>An example of a <code>spawn</code> call:
<pre class="example">     import std::task::*;
     import std::comm::*;
     
     fn helper(c: chan&lt;u8&gt;) {
         // do some work.
         let result = ...;
         send(c, result);
     }
     
     let p: port&lt;u8&gt;;
     
     spawn(bind helper(chan(p)));
     // let task run, do other things.
     // ...
     let result = recv(p);
     
</pre>
   <div class="node">
<a name="Ref.Task.Send"></a>
<a name="Ref_002eTask_002eSend"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTask_002eRecv">Ref.Task.Recv</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask_002eSpawn">Ref.Task.Spawn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.5 Ref.Task.Send</h4>

<!-- * Ref.Task.Send::            Calls for sending a value into a channel. -->
<p><a name="index-Send-call-59"></a><a name="index-Messages-60"></a><a name="index-Communication-61"></a>
Sending a value into a channel is done by a library call to
<code>std::comm::send</code>, which takes a channel and a value to send, and moves
the value into the channel's outgoing buffer.

   <p>An example of a send:
<pre class="example">     import std::comm::*;
     let c: chan&lt;str&gt; = ...;
     send(c, "hello, world");
</pre>
   <div class="node">
<a name="Ref.Task.Recv"></a>
<a name="Ref_002eTask_002eRecv"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask_002eSend">Ref.Task.Send</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTask">Ref.Task</a>

</div>

<h4 class="subsection">4.6.6 Ref.Task.Recv</h4>

<!-- * Ref.Task.Recv::           Calls for receiving a value from a channel. -->
<p><a name="index-Receive-call-62"></a><a name="index-Messages-63"></a><a name="index-Communication-64"></a>
Receiving a value is done by a call to the <code>recv</code> method, on an object of
type <code>std::comm::port</code>. This call causes the receiving task to enter the
<em>blocked reading</em> state until a task is sending a value to the port, at
which point the runtime pseudo-randomly selects a sending task and moves a
value from the head of one of the task queues to the call's return value, and
un-blocks the receiving task. See <a href="#Ref_002eRun_002eComm">Ref.Run.Comm</a>.

   <p>An example of a <em>receive</em>:
<pre class="example">     import std::comm::*;
     let p: port&lt;str&gt; = ...;
     let s: str = recv(p);
</pre>
   <div class="node">
<a name="Ref.Item"></a>
<a name="Ref_002eItem"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType">Ref.Type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTask">Ref.Task</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.7 Ref.Item</h3>

<!-- * Ref.Item::               The components of a module. -->
<p><a name="index-Item-65"></a><a name="index-Type-parameters-66"></a><a name="index-Module-item-67"></a>
An <dfn>item</dfn> is a component of a module. Items are entirely determined at
compile-time, remain constant during execution, and may reside in read-only
memory.

   <p>There are five primary kinds of item: modules, functions, iterators, objects and
type definitions.

   <p>All items form an implicit scope for the declaration of sub-items. In other
words, within a function, object or iterator, declarations of items can (in
many cases) be mixed with the statements, control blocks, and similar
artifacts that otherwise compose the item body. The meaning of these scoped
items is the same as if the item was declared outside the scope, except that
the item's <em>path name</em> within the module namespace is qualified by the
name of the enclosing item. The exact locations in which sub-items may be
declared is given by the grammar.  See <a href="#Ref_002eGram">Ref.Gram</a>.

   <p>Functions, iterators, objects and type definitions may be <em>parametrized</em>
by type. Type parameters are given as a comma-separated list of identifiers
enclosed in angle brackets (<code>&lt;&gt;</code>), after the name of the item and before
its definition.  The type parameters of an item are part of the name, not the
type of the item; in order to refer to the type-parametrized item, a
referencing name must in general provide type arguments as a list of
comma-separated types enclosed within angle brackets. In practice, the
type-inference system can usually infer such argument types from
context. There are no general parametric types.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eItem_002eMod">Ref.Item.Mod</a>:                 Items defining modules. 
<li><a accesskey="2" href="#Ref_002eItem_002eFn">Ref.Item.Fn</a>:                  Items defining functions. 
<li><a accesskey="3" href="#Ref_002eItem_002ePred">Ref.Item.Pred</a>:                Items defining predicates for typestates. 
<li><a accesskey="4" href="#Ref_002eItem_002eIter">Ref.Item.Iter</a>:                Items defining iterators. 
<li><a accesskey="5" href="#Ref_002eItem_002eObj">Ref.Item.Obj</a>:                 Items defining objects. 
<li><a accesskey="6" href="#Ref_002eItem_002eType">Ref.Item.Type</a>:                Items defining the types of values and slots. 
<li><a accesskey="7" href="#Ref_002eItem_002eTag">Ref.Item.Tag</a>:                 Items defining the constructors of a tag type. 
</ul>

<div class="node">
<a name="Ref.Item.Mod"></a>
<a name="Ref_002eItem_002eMod"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eFn">Ref.Item.Fn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.1 Ref.Item.Mod</h4>

<!-- * Ref.Item.Mod::           Items defining sub-modules. -->
<p><a name="index-Module-item-68"></a><a name="index-Importing-names-69"></a><a name="index-Exporting-names-70"></a><a name="index-Visibility-control-71"></a>
A <dfn>module item</dfn> contains declarations of other <em>items</em>. The items
within a module may be functions, modules, objects or types. These
declarations have both static and dynamic interpretation. The purpose of a
module is to organize <em>names</em> and control <em>visibility</em>. Modules are
declared with the keyword <code>mod</code>.

   <p>An example of a module:
<pre class="example">     mod math {
         type complex = (f64,f64);
         fn sin(f64) -&gt; f64 {
             ...
         }
         fn cos(f64) -&gt; f64 {
             ...
         }
         fn tan(f64) -&gt; f64 {
             ...
         }
         ...
     }
</pre>
   <p>Modules may also include any number of <dfn>import and export
declarations</dfn>. These declarations must precede any module item declarations
within the module, and control the visibility of names both within the module
and outside of it.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eItem_002eMod_002eImport">Ref.Item.Mod.Import</a>:             Declarations for module-local synonyms. 
<li><a accesskey="2" href="#Ref_002eItem_002eMod_002eExport">Ref.Item.Mod.Export</a>:             Declarations for restricting visibility. 
</ul>

<div class="node">
<a name="Ref.Item.Mod.Import"></a>
<a name="Ref_002eItem_002eMod_002eImport"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eMod_002eExport">Ref.Item.Mod.Export</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem_002eMod">Ref.Item.Mod</a>

</div>

<h5 class="subsubsection">4.7.1.1 Ref.Item.Mod.Import</h5>

<!-- * Ref.Item.Mod.Import::     Declarations for module-local synonyms. -->
<p><a name="index-Importing-names-72"></a><a name="index-Visibility-control-73"></a>
An <dfn>import declaration</dfn> creates one or more local name bindings synonymous
with some other name. Usually an import declaration is used to shorten the
path required to refer to a module item.

   <p><em>Note</em>: unlike many languages, Rust's <code>import</code> declarations do
<em>not</em> declare linkage-dependency with external crates. Linkage
dependencies are independently declared with <code>use</code>
declarations. See <a href="#Ref_002eComp_002eCrate">Ref.Comp.Crate</a>.

   <p>An example of imports:
<pre class="example">     import std::math::sin;
     import std::option::*;
     import std::str::{char_at, hash};
     
     fn main() {
         // Equivalent to 'log std::math::sin(1.0);'
         log sin(1.0);
         // Equivalent to 'log std::option::some(1.0);'
         log some(1.0);
         // Equivalent to 'log std::str::hash(std::str::char_at("foo"));'
         log hash(char_at("foo"));
     }
</pre>
   <div class="node">
<a name="Ref.Item.Mod.Export"></a>
<a name="Ref_002eItem_002eMod_002eExport"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eMod_002eImport">Ref.Item.Mod.Import</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem_002eMod">Ref.Item.Mod</a>

</div>

<h5 class="subsubsection">4.7.1.2 Ref.Item.Mod.Export</h5>

<!-- * Ref.Item.Mod.Import::     Declarations for restricting visibility. -->
<p><a name="index-Exporting-names-74"></a><a name="index-Visibility-control-75"></a>
An <dfn>export declaration</dfn> restricts the set of local declarations within a
module that can be accessed from code outside the module. By default, all
local declarations in a module are exported. If a module contains an export
declaration, this declaration replaces the default export with the export
specified.

   <p>An example of an export:
<pre class="example">     mod foo {
         export primary;
     
         fn primary() {
             helper(1, 2);
             helper(3, 4);
         }
     
         fn helper(x: int, y: int) {
             ...
         }
     }
     
     fn main() {
         foo::primary();  // Will compile.
         foo::helper(2,3) // ERROR: will not compile.
     }
</pre>
   <p>Multiple items may be exported from a single export declaration:

<pre class="example">     mod foo {
         export primary, secondary;
     
         fn primary() {
             helper(1, 2);
             helper(3, 4);
         }
     
         fn secondary() {
             ...
         }
     
         fn helper(x: int, y: int) {
             ...
         }
     }
</pre>
   <div class="node">
<a name="Ref.Item.Fn"></a>
<a name="Ref_002eItem_002eFn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002ePred">Ref.Item.Pred</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eMod">Ref.Item.Mod</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.2 Ref.Item.Fn</h4>

<!-- * Ref.Item.Fn::            Items defining functions. -->
<p><a name="index-Functions-76"></a><a name="index-Slots_002c-function-input-and-output-77"></a>
A <dfn>function item</dfn> defines a sequence of statements associated with a name
and a set of parameters. Functions are declared with the keyword
<code>fn</code>. Functions declare a set of <em>input slots</em> as parameters,
through which the caller passes arguments into the function, and an
<em>output slot</em> through which the function passes results back to the
caller.

   <p>A function may also be copied into a first class <em>value</em>, in which case
the value has the corresponding <em>function type</em>, and can be used
otherwise exactly as a function item (with a minor additional cost of calling
the function, as such a call is indirect). See <a href="#Ref_002eType_002eFn">Ref.Type.Fn</a>.

   <p>Every control path in a function ends with a <code>ret</code> or <code>be</code>
expression or with a diverging expression (described later in this
section). If a control path lacks a <code>ret</code> expression in source code, an
implicit <code>ret</code> expression is appended to the end of the control path
during compilation, returning the implicit <code>()</code> value.

   <p>An example of a function:
<pre class="example">     fn add(x: int, y: int) -&gt; int {
         ret x + y;
     }
</pre>
   <p>A special kind of function can be declared with a <code>!</code> character where the
output slot type would normally be. For example:
<pre class="example">     fn my_err(s: str) -&gt; ! {
         log s;
         fail;
     }
</pre>
   <p>We call such functions &ldquo;diverging&rdquo; because they never return a value to the
caller. Every control path in a diverging function must end with a <code>fail</code>
or a call to another diverging function on every control path. The <code>!</code>
annotation does <em>not</em> denote a type. Rather, the result type
of a diverging function is a special type called \bot (&ldquo;bottom&rdquo;) that
unifies with any type. Rust has no syntax for \bot.

   <p>It might be necessary to declare a diverging function because as mentioned
previously, the typechecker checks that every control path in a function ends
with a <code>ret</code>, <code>be</code>, or diverging expression. So, if <code>my_err</code>
were declared without the <code>!</code> annotation, the following code would not
typecheck:
<pre class="example">     fn f(i: int) -&gt; int {
        if (i == 42) {
          ret 42;
        }
        else {
          my_err("Bad number!");
        }
     }
</pre>
   <p>The typechecker would complain that <code>f</code> doesn't return a value in the
<code>else</code> branch. Adding the <code>!</code> annotation on <code>my_err</code> would
express that <code>f</code> requires no explicit <code>ret</code>, as if it returns
control to the caller, it returns a value (true because it never returns
control).

<div class="node">
<a name="Ref.Item.Pred"></a>
<a name="Ref_002eItem_002ePred"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eIter">Ref.Item.Iter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eFn">Ref.Item.Fn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.3 Ref.Item.Pred</h4>

<!-- * Ref.Item.Pred::            Items defining predicates. -->
<p><a name="index-Predicate-78"></a>
Any pure boolean function is called a <em>predicate</em>, and may be used
as part of the static typestate system. See <a href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>. A
predicate declaration is identical to a function declaration, except that it
is declared with the additional keyword <code>pure</code>. In addition,
the typechecker checks the body of a predicate with a restricted set of
typechecking rules. A predicate
     <ul>
<li>may not contain a <code>put</code>, <code>send</code>, <code>recv</code>, assignment, or
self-call expression; and
<li>may only call other predicates, not general functions. 
</ul>

   <p>An example of a predicate:
<pre class="example">     pure fn lt_42(x: int) -&gt; bool {
         ret (x &lt; 42);
     }
</pre>
   <p>A non-boolean function may also be declared with <code>pure fn</code>. This allows
predicates to call non-boolean functions as long as they are pure. For example:
<pre class="example">     pure fn pure_length&lt;@T&gt;(ls: list&lt;T&gt;) -&gt; uint { /* ... */ }
     
     pure fn nonempty_list&lt;@T&gt;(ls: list&lt;T&gt;) -&gt; bool { pure_length(ls) &gt; 0u }
</pre>
   <p>In this example, <code>nonempty_list</code> is a predicate&mdash;it can be used in a
typestate constraint&mdash;but the auxiliary function <code>pure_length</code> is
not.

   <p><em>ToDo:</em> should actually define referential transparency.

   <p>The effect checking rules previously enumerated are a restricted set of
typechecking rules meant to approximate the universe of observably
referentially transparent Rust procedures conservatively. Sometimes, these
rules are <em>too</em> restrictive. Rust allows programmers to violate these
rules by writing predicates that the compiler cannot prove to be referentially
transparent, using an escape-hatch feature called &ldquo;unchecked blocks&rdquo;. When
writing code that uses unchecked blocks, programmers should always be aware
that they have an obligation to show that the code <em>behaves</em> referentially
transparently at all times, even if the compiler cannot <em>prove</em>
automatically that the code is referentially transparent. In the presence of
unchecked blocks, the compiler provides no static guarantee that the code will
behave as expected at runtime. Rather, the programmer has an independent
obligation to verify the semantics of the predicates they write.

   <p><em>ToDo:</em> last two sentences are vague.

   <p>An example of a predicate that uses an unchecked block:
<pre class="example">     fn pure_foldl&lt;@T, @U&gt;(ls: list&lt;T&gt;, u: U, f: block(&amp;T, &amp;U) -&gt; U) -&gt; U {
         alt ls {
           nil. { u }
           cons(hd, tl) { f(hd, pure_foldl(*tl, f(hd, u), f)) }
         }
     }
     
     pure fn pure_length&lt;@T&gt;(ls: list&lt;T&gt;) -&gt; uint {
         fn count&lt;T&gt;(_t: T, u: uint) -&gt; uint { u + 1u }
         unchecked {
             pure_foldl(ls, 0u, count)
         }
     }
</pre>
   <p>Despite its name, <code>pure_foldl</code> is a <code>fn</code>, not a <code>pure fn</code>,
because there is no way in Rust to specify that the higher-order function
argument <code>f</code> is a pure function. So, to use <code>foldl</code> in a pure list
length function that a predicate could then use, we must use an
<code>unchecked</code> block wrapped around the call to <code>pure_foldl</code> in the
definition of <code>pure_length</code>.

<div class="node">
<a name="Ref.Item.Iter"></a>
<a name="Ref_002eItem_002eIter"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eObj">Ref.Item.Obj</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002ePred">Ref.Item.Pred</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.4 Ref.Item.Iter</h4>

<!-- * Ref.Item.Iter::          Items defining iterators. -->
<p><a name="index-Iterators-79"></a><a name="index-Put-expression-80"></a><a name="index-Put-each-expression-81"></a><a name="index-Foreach-expression-82"></a>
Iterators are function-like items that can <code>put</code> multiple values during
their execution before returning.

   <p>Putting a value is similar to returning a value &ndash; the argument to <code>put</code>
is copied into the caller's frame and control transfers back to the caller &ndash;
but the iterator frame is only <em>suspended</em> during the put, and will be
<em>resumed</em> at the point after the <code>put</code>, on the next iteration of
the caller's loop.

   <p>The output type of an iterator is the type of value that the function will
<code>put</code>, before it eventually evaluates a <code>ret</code> or <code>be</code> expression
of type <code>()</code> and completes its execution.

   <p>An iterator can be called only in the loop header of a matching <code>for
each</code> loop or as the argument in a <code>put each</code> expression. 
See <a href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a>.

   <p>An example of an iterator:
<pre class="example">     iter range(lo: int, hi: int) -&gt; int {
         let i: int = lo;
         while (i &lt; hi) {
             put i;
             i = i + 1;
         }
     }
     
     let sum: int = 0;
     for each (x: int in range(0,100)) {
         sum += x;
     }
</pre>
   <div class="node">
<a name="Ref.Item.Obj"></a>
<a name="Ref_002eItem_002eObj"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eType">Ref.Item.Type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eIter">Ref.Item.Iter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.5 Ref.Item.Obj</h4>

<!-- * Ref.Item.Obj::          Items defining objects. -->
<p><a name="index-Objects-83"></a><a name="index-Object-constructors-84"></a>
An <dfn>object item</dfn> defines the <em>state</em> and <em>methods</em> of a set of
<em>object values</em>. Object values have object types.  See <a href="#Ref_002eType_002eObj">Ref.Type.Obj</a>.

   <p>An <em>object item</em> declaration &ndash; in addition to providing a scope for
state and method declarations &ndash; implicitly declares a static function called
the <em>object constructor</em>, as well as a named <em>object type</em>. The name
given to the object item is resolved to a type when used in type context, or a
constructor function when used in value context (such as a call).

   <p>Example of an object item:
<pre class="example">     obj counter(state: @mutable int) {
         fn incr() {
            *state += 1;
         }
         fn get() -&gt; int {
            ret *state;
         }
     }
     
     let c: counter = counter(@mutable 1);
     
     c.incr();
     c.incr();
     assert c.get() == 3;
</pre>
   <p>Inside an object's methods, you can make <em>self-calls</em> using the
<code>self</code> keyword.
<pre class="example">     obj my_obj() {
       fn get() -&gt; int {
         ret 3;
       }
       fn foo() -&gt; int {
         let c = self.get();
         ret c + 2;
       }
     }
     
     let o = my_obj();
     assert o.foo() == 5;
</pre>
   <p>Rust objects are extendable with additional methods and fields using
<em>anonymous object</em> expressions.  See <a href="#Ref_002eExpr_002eAnonObj">Ref.Expr.AnonObj</a>.

<div class="node">
<a name="Ref.Item.Type"></a>
<a name="Ref_002eItem_002eType"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eItem_002eTag">Ref.Item.Tag</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eObj">Ref.Item.Obj</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.6 Ref.Item.Type</h4>

<!-- * Ref.Item.Type::          Items defining the types of values and slots. -->
<p><a name="index-Type-definitions-85"></a>
A <dfn>type definition</dfn> defines a set of possible values in
memory. See <a href="#Ref_002eType">Ref.Type</a>. Type definitions are declared with the keyword
<code>type</code>. Every value has a single, specific type; the type-specified
aspects of a value include:

     <ul>
<li>Whether the value is composed of sub-values or is indivisible. 
<li>Whether the value represents textual or numerical information. 
<li>Whether the value represents integral or floating-point information. 
<li>The sequence of memory operations required to access the value. 
<li>The <em>kind</em> of the type (pinned, unique or shared). 
</ul>

   <p>For example, the type <code>{x: u8, y: u8}</code> defines the set of immutable
values that are composite records, each containing two unsigned 8-bit integers
accessed through the components <code>x</code> and <code>y</code>, and laid out in memory
with the <code>x</code> component preceding the <code>y</code> component. This type is of
<em>unique</em> kind, meaning that there is no shared substructure with other
types, but it can be copied and moved freely.

<div class="node">
<a name="Ref.Item.Tag"></a>
<a name="Ref_002eItem_002eTag"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem_002eType">Ref.Item.Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eItem">Ref.Item</a>

</div>

<h4 class="subsection">4.7.7 Ref.Item.Tag</h4>

<!-- * Ref.Item.Type::          Items defining the constructors of a tag type. -->
<p><a name="index-Tag-types-86"></a>
A tag item simultaneously declares a new nominal tag type
(see <a href="#Ref_002eType_002eTag">Ref.Type.Tag</a>) as well as a set of <em>constructors</em> that can be
used to create or pattern-match values of the corresponding tag type.

   <p>The constructors of a <code>tag</code> type may be recursive: that is, each constructor
may take an argument that refers, directly or indirectly, to the tag type the constructor
is a member of. Such recursion has restrictions:
     <ul>
<li>Recursive types can be introduced only through <code>tag</code> constructors. 
<li>A recursive <code>tag</code> item must have at least one non-recursive
constructor (in order to give the recursion a basis case). 
<li>The recursive argument of recursive tag constructors must be <em>box</em>
values (in order to bound the in-memory size of the constructor). 
<li>Recursive type definitions can cross module boundaries, but not module
<em>visibility</em> boundaries, nor crate boundaries (in order to simplify the
module system). 
</ul>

   <p>An example of a <code>tag</code> item and its use:
<pre class="example">     tag animal {
       dog;
       cat;
     }
     
     let a: animal = dog;
     a = cat;
</pre>
   <p>An example of a <em>recursive</em> <code>tag</code> item and its use:
<pre class="example">     tag list&lt;T&gt; {
       nil;
       cons(T, @list&lt;T&gt;);
     }
     
     let a: list&lt;int&gt; = cons(7, cons(13, nil));
</pre>
   <div class="node">
<a name="Ref.Type"></a>
<a name="Ref_002eType"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate">Ref.Typestate</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eItem">Ref.Item</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.8 Ref.Type</h3>

<p><a name="index-Types-87"></a>
Every slot and value in a Rust program has a type. The <dfn>type</dfn> of a
<em>value</em> defines the interpretation of the memory holding it. The type of
a <em>slot</em> may also include constraints. See <a href="#Ref_002eType_002eConstr">Ref.Type.Constr</a>.

   <p>Built-in types and type-constructors are tightly integrated into the language,
in nontrivial ways that are not possible to emulate in user-defined
types. User-defined types have limited capabilities. In addition, every
built-in type or type-constructor name is reserved as a <em>keyword</em> in
Rust; they cannot be used as user-defined identifiers in any context.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eType_002eAny">Ref.Type.Any</a>:                 An open union of every possible type. 
<li><a accesskey="2" href="#Ref_002eType_002eMach">Ref.Type.Mach</a>:                Machine-level types. 
<li><a accesskey="3" href="#Ref_002eType_002eInt">Ref.Type.Int</a>:                 The machine-dependent integer types. 
<li><a accesskey="4" href="#Ref_002eType_002eFloat">Ref.Type.Float</a>:               The machine-dependent floating-point types. 
<li><a accesskey="5" href="#Ref_002eType_002ePrim">Ref.Type.Prim</a>:                Primitive types. 
<li><a accesskey="6" href="#Ref_002eType_002eBig">Ref.Type.Big</a>:                 The arbitrary-precision integer type. 
<li><a accesskey="7" href="#Ref_002eType_002eText">Ref.Type.Text</a>:                Strings and characters. 
<li><a accesskey="8" href="#Ref_002eType_002eRec">Ref.Type.Rec</a>:                 Labeled products of heterogeneous types. 
<li><a accesskey="9" href="#Ref_002eType_002eTup">Ref.Type.Tup</a>:                 Unlabeled products of heterogeneous types. 
<li><a href="#Ref_002eType_002eVec">Ref.Type.Vec</a>:                 Open products of homogeneous types. 
<li><a href="#Ref_002eType_002eTag">Ref.Type.Tag</a>:                 Disjoint unions of heterogeneous types. 
<li><a href="#Ref_002eType_002eFn">Ref.Type.Fn</a>:                  Subroutine types. 
<li><a href="#Ref_002eType_002eIter">Ref.Type.Iter</a>:                Scoped coroutine types. 
<li><a href="#Ref_002eType_002eObj">Ref.Type.Obj</a>:                 Abstract types. 
<li><a href="#Ref_002eType_002eConstr">Ref.Type.Constr</a>:              Constrained types. 
<li><a href="#Ref_002eType_002eType">Ref.Type.Type</a>:                Types describing types. 
</ul>

<div class="node">
<a name="Ref.Type.Any"></a>
<a name="Ref_002eType_002eAny"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eMach">Ref.Type.Mach</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.1 Ref.Type.Any</h4>

<p><a name="index-Any-type-88"></a><a name="index-Dynamic-type_002c-see-_0040i_007bAny-type_007d-89"></a><a name="index-Alt-type-expression-90"></a>
The type <code>any</code> is the union of all possible Rust types. A value of type
<code>any</code> is represented in memory as a pair consisting of a boxed value of
some non-<code>any</code> type <var>T</var> and a reflection of the type <var>T</var>.

   <p>Values of type <code>any</code> can be used in an <code>alt type</code> expression, in
which the reflection is used to select a block corresponding to a particular
type extraction. See <a href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>.

<div class="node">
<a name="Ref.Type.Mach"></a>
<a name="Ref_002eType_002eMach"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eInt">Ref.Type.Int</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eAny">Ref.Type.Any</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.2 Ref.Type.Mach</h4>

<p><a name="index-Machine-types-91"></a><a name="index-Floating_002dpoint-types-92"></a><a name="index-Integer-types-93"></a><a name="index-Word-types-94"></a>
The machine types are the following:

     <ul>
<li>The unsigned word types <code>u8</code>, <code>u16</code>, <code>u32</code> and <code>u64</code>,
with values drawn from the integer intervals
[0, 2<sup>8</sup>-1],
[0, 2<sup>16</sup>-1],
[0, 2<sup>32</sup>-1] and
[0, 2<sup>64</sup>-1] respectively. 
<li>The signed two's complement word types <code>i8</code>, <code>i16</code>, <code>i32</code> and
<code>i64</code>, with values drawn from the integer intervals
[-(2<sup>7</sup>), 2<sup>7</sup>-1],
[-(2<sup>15</sup>), 2<sup>15</sup>-1],
[-(2<sup>31</sup>), 2<sup>31</sup>-1] and
[-(2<sup>63</sup>), 2<sup>63</sup>-1] respectively. 
<li>The IEEE 754-2008 <code>binary32</code> and <code>binary64</code> floating-point types:
<code>f32</code> and <code>f64</code>, respectively. 
</ul>

<div class="node">
<a name="Ref.Type.Int"></a>
<a name="Ref_002eType_002eInt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eFloat">Ref.Type.Float</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eMach">Ref.Type.Mach</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.3 Ref.Type.Int</h4>

<p><a name="index-Machine_002ddependent-types-95"></a><a name="index-Integer-types-96"></a><a name="index-Word-types-97"></a>

   <p>The Rust type <code>uint</code><a rel="footnote" href="#fn-6" name="fnd-6"><sup>6</sup></a> is an unsigned integer type with with
target-machine-dependent size. Its size, in bits, is equal to the number of
bits required to hold any memory address on the target machine.

   <p>The Rust type <code>int</code><a rel="footnote" href="#fn-7" name="fnd-7"><sup>7</sup></a> is a two's complement signed integer type with
target-machine-dependent size. Its size, in bits, is equal to the size of the
rust type <code>uint</code> on the same target machine.

<div class="node">
<a name="Ref.Type.Float"></a>
<a name="Ref_002eType_002eFloat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002ePrim">Ref.Type.Prim</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eInt">Ref.Type.Int</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.4 Ref.Type.Float</h4>

<p><a name="index-Machine_002ddependent-types-98"></a><a name="index-Floating_002dpoint-types-99"></a>
The Rust type <code>float</code> is a machine-specific type equal to one of the
supported Rust floating-point machine types (<code>f32</code> or <code>f64</code>). It is
the largest floating-point type that is directly supported by hardware on the
target machine, or if the target machine has no floating-point hardware
support, the largest floating-point type supported by the software
floating-point library used to support the other floating-point machine types.

   <p>Note that due to the preference for hardware-supported floating-point, the
type <code>float</code> may not be equal to the largest <em>supported</em>
floating-point type.

<div class="node">
<a name="Ref.Type.Prim"></a>
<a name="Ref_002eType_002ePrim"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eBig">Ref.Type.Big</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eFloat">Ref.Type.Float</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.5 Ref.Type.Prim</h4>

<p><a name="index-Primitive-types-100"></a><a name="index-Integer-types-101"></a><a name="index-Floating_002dpoint-types-102"></a><a name="index-Character-type-103"></a><a name="index-Boolean-type-104"></a>
The primitive types are the following:

     <ul>
<li>The &ldquo;nil&rdquo; type <code>()</code>, having the single &ldquo;nil&rdquo; value
<code>()</code>.<a rel="footnote" href="#fn-8" name="fnd-8"><sup>8</sup></a>
<li>The boolean type <code>bool</code> with values <code>true</code> and <code>false</code>. 
<li>The machine types. 
<li>The machine-dependent integer and floating-point types. 
</ul>

<div class="node">
<a name="Ref.Type.Big"></a>
<a name="Ref_002eType_002eBig"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eText">Ref.Type.Text</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002ePrim">Ref.Type.Prim</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.6 Ref.Type.Big</h4>

<p><a name="index-Integer-types-105"></a><a name="index-Big-integer-type-106"></a>
The Rust type <code>big</code><a rel="footnote" href="#fn-9" name="fnd-9"><sup>9</sup></a> is an arbitrary precision integer type that
fits in a machine word <em>when possible</em> and transparently expands to a
boxed &ldquo;big integer&rdquo; allocated in the run-time heap when it overflows or
underflows outside of the range of a machine word.

   <p>A Rust <code>big</code> grows to accommodate extra binary digits as they are needed,
by taking extra memory from the memory budget available to each Rust task, and
should only exhaust its range due to memory exhaustion.

<div class="node">
<a name="Ref.Type.Text"></a>
<a name="Ref_002eType_002eText"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eRec">Ref.Type.Rec</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eBig">Ref.Type.Big</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.7 Ref.Type.Text</h4>

<p><a name="index-Text-types-107"></a><a name="index-String-type-108"></a><a name="index-Character-type-109"></a><a name="index-Unicode-110"></a><a name="index-UCS_002d4-111"></a><a name="index-UTF_002d8-112"></a>
The types <code>char</code> and <code>str</code> hold textual data.

   <p>A value of type <code>char</code> is a Unicode character, represented as a 32-bit
unsigned word holding a UCS-4 codepoint.

   <p>A value of type <code>str</code> is a Unicode string, represented as a vector of
8-bit unsigned bytes holding a sequence of UTF-8 codepoints.

<div class="node">
<a name="Ref.Type.Rec"></a>
<a name="Ref_002eType_002eRec"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eTup">Ref.Type.Tup</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eText">Ref.Type.Text</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.8 Ref.Type.Rec</h4>

<p><a name="index-Record-types-113"></a><a name="index-Structure-types_002c-see-_0040i_007bRecord-types_007d-114"></a>
The record type-constructor forms a new heterogeneous product of
values.<a rel="footnote" href="#fn-10" name="fnd-10"><sup>10</sup></a> Fields of a record
type are accessed by name and are arranged in memory in the order specified by
the record type.

   <p>An example of a record type and its use:
<pre class="example">     type point = {x: int, y: int};
     let p: point = {x: 10, y: 11};
     let px: int = p.x;
</pre>
   <div class="node">
<a name="Ref.Type.Tup"></a>
<a name="Ref_002eType_002eTup"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eVec">Ref.Type.Vec</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eRec">Ref.Type.Rec</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.9 Ref.Type.Tup</h4>

<p><a name="index-Tuple-types-115"></a>
The tuple type-constructor forms a new heterogeneous product of
values similar to the record type-constructor. The differences are as follows:

     <ul>
<li>tuple elements cannot be mutable, unlike record fields
<li>tuple elements are not named and can be accessed only by pattern-matching
</ul>

   <p>Tuple types and values are denoted by listing the types or values of
their elements, respectively, in a parenthesized, comma-separated
list. Single-element tuples are not legal; all tuples have two or more values.

   <p>The members of a tuple are laid out in memory contiguously, like a record, in
order specified by the tuple type.

   <p>An example of a tuple type and its use:
<pre class="example">     type pair = (int,str);
     let p: pair = (10,"hello");
     let (a, b) = p;
     assert (b == "world");
</pre>
   <div class="node">
<a name="Ref.Type.Vec"></a>
<a name="Ref_002eType_002eVec"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eTag">Ref.Type.Tag</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eTup">Ref.Type.Tup</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.10 Ref.Type.Vec</h4>

<p><a name="index-Vector-types-116"></a><a name="index-Array-types_002c-see-_0040i_007bVector-types_007d-117"></a>
The vector type-constructor represents a homogeneous array of values of a
given type. A vector has a fixed size. The kind of a vector type depends on
the kind of its member type, as with other simple structural types.

   <p>An example of a vector type and its use:
<pre class="example">     let v: [int] = [7, 5, 3];
     let i: int = v[2];
     assert (i == 3);
</pre>
   <p>Vectors always <em>allocate</em> a storage region sufficient to store the first
power of two worth of elements greater than or equal to the size of the
vector. This behaviour supports idiomatic in-place &ldquo;growth&rdquo; of a mutable
slot holding a vector:

<pre class="example">     let v: mutable [int] = [1, 2, 3];
     v += [4, 5, 6];
</pre>
   <p>Normal vector concatenation causes the allocation of a fresh vector to hold
the result; in this case, however, the slot holding the vector recycles the
underlying storage in-place (since the reference-count of the underlying
storage is equal to 1).

   <p>All accessible elements of a vector are always initialized, and access to a
vector is always bounds-checked.

<div class="node">
<a name="Ref.Type.Tag"></a>
<a name="Ref_002eType_002eTag"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eFn">Ref.Type.Fn</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eVec">Ref.Type.Vec</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.11 Ref.Type.Tag</h4>

<p><a name="index-Tag-types-118"></a><a name="index-Union-types_002c-see-_0040i_007bTag-types_007d-119"></a>
A <em>tag type</em> is a nominal, heterogeneous disjoint union
type.<a rel="footnote" href="#fn-11" name="fnd-11"><sup>11</sup></a> A <code>tag</code> <em>item</em>
consists of a number of <em>constructors</em>, each of which is independently
named and takes an optional tuple of arguments.

   <p>Tag types cannot be denoted <em>structurally</em> as types, but must be denoted
by named reference to a <em>tag item</em> declaration. See <a href="#Ref_002eItem_002eTag">Ref.Item.Tag</a>.

<div class="node">
<a name="Ref.Type.Fn"></a>
<a name="Ref_002eType_002eFn"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eIter">Ref.Type.Iter</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eTag">Ref.Type.Tag</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.12 Ref.Type.Fn</h4>

<p><a name="index-Function-types-120"></a>
The function type-constructor <code>fn</code> forms new function types. A function
type consists of a sequence of input slots, an optional set of input
constraints (see <a href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>) and an output
slot. See <a href="#Ref_002eItem_002eFn">Ref.Item.Fn</a>.

   <p>An example of a <code>fn</code> type:
<pre class="example">     fn add(x: int, y: int) -&gt; int {
       ret x + y;
     }
     
     let int x = add(5,7);
     
     type binop = fn(int,int) -&gt; int;
     let bo: binop = add;
     x = bo(5,7);
</pre>
   <div class="node">
<a name="Ref.Type.Iter"></a>
<a name="Ref_002eType_002eIter"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eObj">Ref.Type.Obj</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eFn">Ref.Type.Fn</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.13 Ref.Type.Iter</h4>

<p><a name="index-Iterator-types-121"></a>
The iterator type-constructor <code>iter</code> forms new iterator types. An
iterator type consists a sequence of input slots, an optional set of input
constraints and an output slot. See <a href="#Ref_002eItem_002eIter">Ref.Item.Iter</a>.

   <p>An example of an <code>iter</code> type:
<pre class="example">     iter range(x: int, y: int) -&gt; int {
       while (x &lt; y) {
         put x;
         x += 1;
       }
     }
     
     for each (i: int in range(5,7)) {
       ...;
     }
</pre>
   <div class="node">
<a name="Ref.Type.Obj"></a>
<a name="Ref_002eType_002eObj"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eConstr">Ref.Type.Constr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eIter">Ref.Type.Iter</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.14 Ref.Type.Obj</h4>

<!-- * Ref.Type.Obj::                Object types. -->
<p><a name="index-Object-types-122"></a>
A <dfn>object type</dfn> describes values of abstract type, that carry some hidden
<em>fields</em> and are accessed through a set of un-ordered
<em>methods</em>. Every object item (see <a href="#Ref_002eItem_002eObj">Ref.Item.Obj</a>) implicitly declares
an object type carrying methods with types derived from all the methods of the
object item.

   <p>Object types can also be declared in isolation, independent of any object item
declaration. Such a &ldquo;plain&rdquo; object type can be used to describe an interface
that a variety of particular objects may conform to, by supporting a superset
of the methods.

   <p>The kind of an object type serves as a restriction to the kinds of fields that
may be stored in it. Unique objects, for example, can only carry unique values
in their fields.

   <p>An example of an object type with two separate object items supporting it, and
a client function using both items via the object type:

<pre class="example">     
     type taker =
         obj {
             fn take(int);
         };
     
     obj adder(x: @mutable int) {
         fn take(y: int) {
             *x += y;
         }
     }
     
     obj sender(c: chan&lt;int&gt;) {
         fn take(z: int) {
             std::comm::send(c, z);
         }
     }
     
     fn give_ints(t: taker) {
         t.take(1);
         t.take(2);
         t.take(3);
     }
     
     let p: port&lt;int&gt; = std::comm::mk_port();
     
     let t1: taker = adder(@mutable 0);
     let t2: taker = sender(p.mk_chan());
     
     give_ints(t1);
     give_ints(t2);
     
</pre>
   <div class="node">
<a name="Ref.Type.Constr"></a>
<a name="Ref_002eType_002eConstr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eType_002eType">Ref.Type.Type</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eObj">Ref.Type.Obj</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.15 Ref.Type.Constr</h4>

<!-- * Ref.Type.Constr::             Constrained types. -->
<p><a name="index-Constrained-types-123"></a>
A <dfn>constrained type</dfn> is a type that carries a <em>formal constraint</em>
(see <a href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>), which is similar to a normal constraint except
that the <em>base name</em> of any slots mentioned in the constraint must be the
special <em>formal symbol</em> <em>*</em>.

   <p>When a constrained type is instantiated in a particular slot declaration, the
formal symbol in the constraint is replaced with the name of the declared slot
and the resulting constraint is checked immediately after the slot is
declared. See <a href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a>.

   <p>An example of a constrained type with two separate instantiations:
<pre class="example">     type ordered_range = {low: int, high: int} : less_than(*.low, *.high);
     
     let rng1: ordered_range = {low: 5, high: 7};
     // implicit: 'check less_than(rng1.low, rng1.high);'
     
     let rng2: ordered_range = {low: 15, high: 17};
     // implicit: 'check less_than(rng2.low, rng2.high);'
</pre>
   <div class="node">
<a name="Ref.Type.Type"></a>
<a name="Ref_002eType_002eType"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType_002eConstr">Ref.Type.Constr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eType">Ref.Type</a>

</div>

<h4 class="subsection">4.8.16 Ref.Type.Type</h4>

<!-- * Ref.Type.Type::               Types describing types. -->
<p><a name="index-Type-type-124"></a>
<em>TODO</em>.

<div class="node">
<a name="Ref.Typestate"></a>
<a name="Ref_002eTypestate"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eStmt">Ref.Stmt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eType">Ref.Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.9 Ref.Typestate</h3>

<!-- * Ref.Typestate::         The static system of predicate analysis. -->
<p><a name="index-Typestate-system-125"></a>
Rust programs have a static semantics that determine the types of values
produced by each expression, as well as the <em>predicates</em> that hold over
slots in the environment at each point in time during execution.

   <p>The latter semantics &ndash; the dataflow analysis of predicates holding over slots
&ndash; is called the <em>typestate</em> system.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eTypestate_002ePoint">Ref.Typestate.Point</a>:          Discrete positions in execution. 
<li><a accesskey="2" href="#Ref_002eTypestate_002eCFG">Ref.Typestate.CFG</a>:            The control-flow graph formed by points. 
<li><a accesskey="3" href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>:         Predicates applied to slots. 
<li><a accesskey="4" href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a>:           Constraints required and implied by a point. 
<li><a accesskey="5" href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a>:          Constraints that hold at points. 
<li><a accesskey="6" href="#Ref_002eTypestate_002eCheck">Ref.Typestate.Check</a>:          Relating dynamic state to static typestate. 
</ul>

<div class="node">
<a name="Ref.Typestate.Point"></a>
<a name="Ref_002eTypestate_002ePoint"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate_002eCFG">Ref.Typestate.CFG</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.1 Ref.Typestate.Point</h4>

<!-- * Ref.Typestate.Point::         Discrete positions in execution. -->
<p><a name="index-Points-126"></a>
Control flows from statement to statement in a block, and through the
evaluation of each expression, from one sub-expression to another. This
sequential control flow is specified as a set of <dfn>points</dfn>, each of which
has a set of points before and after it in the implied control flow.

   <p>For example, this code:

<pre class="example">      s = "hello, world";
      print(s);
</pre>
   <p>Consists of 2 statements, 3 expressions and 12 points:

     <ul>
<li>the point before the first statement
<li>the point before evaluating the static initializer <code>"hello, world"</code>
<li>the point after evaluating the static initializer <code>"hello, world"</code>
<li>the point after the first statement
<li>the point before the second statement
<li>the point before evaluating the function value <code>print</code>
<li>the point after evaluating the function value <code>print</code>
<li>the point before evaluating the arguments to <code>print</code>
<li>the point before evaluating the symbol <code>s</code>
<li>the point after evaluating the symbol <code>s</code>
<li>the point after evaluating the arguments to <code>print</code>
<li>the point after the second statement
</ul>

   <p>Whereas this code:

<pre class="example">      print(x() + y());
</pre>
   <p>Consists of 1 statement, 7 expressions and 14 points:

     <ul>
<li>the point before the statement
<li>the point before evaluating the function value <code>print</code>
<li>the point after evaluating the function value <code>print</code>
<li>the point before evaluating the arguments to <code>print</code>
<li>the point before evaluating the arguments to <code>+</code>
<li>the point before evaluating the function value <code>x</code>
<li>the point after evaluating the function value <code>x</code>
<li>the point before evaluating the arguments to <code>x</code>
<li>the point after evaluating the arguments to <code>x</code>
<li>the point before evaluating the function value <code>y</code>
<li>the point after evaluating the function value <code>y</code>
<li>the point before evaluating the arguments to <code>y</code>
<li>the point after evaluating the arguments to <code>y</code>
<li>the point after evaluating the arguments to <code>+</code>
<li>the point after evaluating the arguments to <code>print</code>
</ul>

   <p>The typestate system reasons over points, rather than statements or
expressions. This may seem counter-intuitive, but points are the more
primitive concept. Another way of thinking about a point is as a set of
<em>instants in time</em> at which the state of a task is fixed. By contrast, a
statement or expression represents a <em>duration in time</em>, during which the
state of the task changes. The typestate system is concerned with constraining
the possible states of a task's memory at <em>instants</em>; it is meaningless
to speak of the state of a task's memory &ldquo;at&rdquo; a statement or expression, as
each statement or expression is likely to change the contents of memory.

<div class="node">
<a name="Ref.Typestate.CFG"></a>
<a name="Ref_002eTypestate_002eCFG"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate_002ePoint">Ref.Typestate.Point</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.2 Ref.Typestate.CFG</h4>

<!-- * Ref.Typestate.CFG::           The control-flow graph formed by points. -->
<p><a name="index-Control_002dflow-graph-127"></a>
Each <em>point</em> can be considered a vertex in a directed <em>graph</em>. Each
kind of expression or statement implies a number of points <em>and edges</em> in
this graph. The edges connect the points within each statement or expression,
as well as between those points and those of nearby statements and expressions
in the program. The edges between points represent <em>possible</em> indivisible
control transfers that might occur during execution.

   <p>This implicit graph is called the <dfn>control-flow graph</dfn>, or <dfn>CFG</dfn>.

<div class="node">
<a name="Ref.Typestate.Constr"></a>
<a name="Ref_002eTypestate_002eConstr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate_002eCFG">Ref.Typestate.CFG</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.3 Ref.Typestate.Constr</h4>

<!-- * Ref.Typestate.Constr::          Predicates applied to slots. -->
<p><a name="index-Predicate-128"></a><a name="index-Constraint-129"></a>
A <dfn>predicate</dfn> is a pure boolean function declared with the keyword
<code>pred</code>. See <a href="#Ref_002eItem_002ePred">Ref.Item.Pred</a>.

   <p>A <dfn>constraint</dfn> is a predicate applied to specific slots.

   <p>For example, consider the following code:

<pre class="example">     pure fn is_less_than(int a, int b) -&gt; bool {
          ret a &lt; b;
     }
     
     fn test() {
        let x: int = 10;
        let y: int = 20;
        check is_less_than(x,y);
     }
</pre>
   <p>This example defines the predicate <code>is_less_than</code>, and applies it to the
slots <code>x</code> and <code>y</code>. The constraint being checked on the third line of
the function is <code>is_less_than(x,y)</code>.

   <p>Predicates can only apply to slots holding immutable values. The slots a
predicate applies to can themselves be mutable, but the types of values held
in those slots must be immutable.

<div class="node">
<a name="Ref.Typestate.Cond"></a>
<a name="Ref_002eTypestate_002eCond"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.4 Ref.Typestate.Cond</h4>

<!-- * Ref.Typestate.Cond::          Constraints required and implied by a point. -->
<p><a name="index-Condition-130"></a><a name="index-Precondition-131"></a><a name="index-Postcondition-132"></a>
A <dfn>condition</dfn> is a set of zero or more constraints.

   <p>Each <em>point</em> has an associated <em>condition</em>:

     <ul>
<li>The <dfn>precondition</dfn> of a statement or expression is the condition
required at in the point before it. 
<li>The <dfn>postcondition</dfn> of a statement or expression is the condition
enforced in the point after it. 
</ul>

   <p>Any constraint present in the precondition and <em>absent</em> in the
postcondition is considered to be <em>dropped</em> by the statement or
expression.

<div class="node">
<a name="Ref.Typestate.State"></a>
<a name="Ref_002eTypestate_002eState"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eTypestate_002eCheck">Ref.Typestate.Check</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.5 Ref.Typestate.State</h4>

<!-- * Ref.Typestate.State::     Constraints that hold at points. -->
<p><a name="index-Typestate-133"></a><a name="index-Prestate-134"></a><a name="index-Poststate-135"></a>
The typestate checking system <em>calculates</em> an additional condition for
each point called its typestate. For a given statement or expression, we call
the two typestates associated with its two points the prestate and a
poststate.

     <ul>
<li>The <dfn>prestate</dfn> of a statement or expression is the typestate of the
point before it. 
<li>The <dfn>poststate</dfn> of a statement or expression is the typestate of the
point after it. 
</ul>

   <p>A <dfn>typestate</dfn> is a condition that has <em>been determined by the
typestate algorithm</em> to hold at a point. This is a subtle but important point
to understand: preconditions and postconditions are <em>inputs</em> to the
typestate algorithm; prestates and poststates are <em>outputs</em> from the
typestate algorithm.

   <p>The typestate algorithm analyses the preconditions and postconditions of every
statement and expression in a block, and computes a condition for each
typestate. Specifically:

     <ul>
<li>Initially, every typestate is empty. 
<li>Each statement or expression's poststate is given the union of the its
prestate, precondition, and postcondition. 
<li>Each statement or expression's poststate has the difference between its
precondition and postcondition removed. 
<li>Each statement or expression's prestate is given the intersection of the
poststates of every predecessor point in the CFG. 
<li>The previous three steps are repeated until no typestates in the
block change. 
</ul>

   <p>The typestate algorithm is a very conventional dataflow calculation, and can
be performed using bit-set operations, with one bit per predicate and one
bit-set per condition.

   <p>After the typestates of a block are computed, the typestate algorithm checks
that every constraint in the precondition of a statement is satisfied by its
prestate. If any preconditions are not satisfied, the mismatch is considered a
static (compile-time) error.

<div class="node">
<a name="Ref.Typestate.Check"></a>
<a name="Ref_002eTypestate_002eCheck"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eTypestate">Ref.Typestate</a>

</div>

<h4 class="subsection">4.9.6 Ref.Typestate.Check</h4>

<!-- * Ref.Typestate.Check::         Relating dynamic state to static typestate. -->
<p><a name="index-Check-statement-136"></a><a name="index-Assertions_002c-see-_0040i_007bCheck-statement_007d-137"></a>
The key mechanism that connects run-time semantics and compile-time analysis
of typestates is the use of <code>check</code> expressions. See <a href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a>. A
<code>check</code> expression guarantees that <em>if</em> control were to proceed past
it, the predicate associated with the <code>check</code> would have succeeded, so
the constraint being checked <em>statically</em> holds in subsequent
points.<a rel="footnote" href="#fn-12" name="fnd-12"><sup>12</sup></a>

   <p>It is important to understand that the typestate system has <em>no insight</em>
into the meaning of a particular predicate. Predicates and constraints are not
evaluated in any way at compile time. Predicates are treated as specific (but
unknown) functions applied to specific (also unknown) slots. All the typestate
system does is track which of those predicates &ndash; whatever they calculate &ndash;
<em>must have been checked already</em> in order for program control to reach a
particular point in the CFG. The fundamental building block, therefore, is the
<code>check</code> statement, which tells the typestate system &ldquo;if control passes
this point, the checked predicate holds&rdquo;.

   <p>From this building block, constraints can be propagated to function signatures
and constrained types, and the responsibility to <code>check</code> a constraint
pushed further and further away from the site at which the program requires it
to hold in order to execute properly.

<div class="node">
<a name="Ref.Stmt"></a>
<a name="Ref_002eStmt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr">Ref.Expr</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eTypestate">Ref.Typestate</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.10 Ref.Stmt</h3>

<!-- * Ref.Stmt::               Components of an executable block. -->
<p><a name="index-Statements-138"></a>
A <dfn>statement</dfn> is a component of a block, which is in turn a component of
an outer block-expression, a function or an iterator. When a function is
spawned into a task, the task <em>executes</em> statements in an order
determined by the body of the enclosing structure. Each statement causes the
task to perform certain actions.

   <p>Rust has two kinds of statement: declarations and expressions.

   <p>A declaration serves to introduce a <em>name</em> that can be used in the block
<em>scope</em> enclosing the statement: all statements before and after the
name, from the previous opening curly-brace (<code>{</code>) up to the next closing
curly-brace (<code>}</code>).

   <p>An expression serves the dual roles of causing side effects and producing a
<em>value</em>. Expressions are said to <em>evaluate to</em> a value, and the side
effects are caused during <em>evaluation</em>. Many expressions contain
sub-expressions as operands; the definition of each kind of expression
dictates whether or not, and in which order, it will evaluate its
sub-expressions, and how the expression's value derives from the value of its
sub-expressions.

   <p>In this way, the structure of execution &ndash; both the overall sequence of
observable side effects and the final produced value &ndash; is dictated by the
structure of expressions. Blocks themselves are expressions, so the nesting
sequence of block, statement, expression, and block can repeatedly nest to an
arbitrary depth.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eStmt_002eDecl">Ref.Stmt.Decl</a>:                Statement declaring an item or slot. 
<li><a accesskey="2" href="#Ref_002eStmt_002eExpr">Ref.Stmt.Expr</a>:                Statement evaluating an expression. 
</ul>

<div class="node">
<a name="Ref.Stmt.Decl"></a>
<a name="Ref_002eStmt_002eDecl"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eStmt_002eExpr">Ref.Stmt.Expr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eStmt">Ref.Stmt</a>

</div>

<h4 class="subsection">4.10.1 Ref.Stmt.Decl</h4>

<!-- * Ref.Stmt.Decl::                Statement declaring an item or slot. -->
<p><a name="index-Declaration-statement-139"></a>
A <dfn>declaration statement</dfn> is one that introduces a <em>name</em> into the
enclosing statement block. The declared name may denote a new slot or a new
item. The scope of the name extends to the entire containing block, both
before and after the declaration.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eStmt_002eDecl_002eItem">Ref.Stmt.Decl.Item</a>:               Statement declaring an item. 
<li><a accesskey="2" href="#Ref_002eStmt_002eDecl_002eSlot">Ref.Stmt.Decl.Slot</a>:               Statement declaring a slot. 
</ul>

<div class="node">
<a name="Ref.Stmt.Decl.Item"></a>
<a name="Ref_002eStmt_002eDecl_002eItem"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eStmt_002eDecl_002eSlot">Ref.Stmt.Decl.Slot</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eStmt_002eDecl">Ref.Stmt.Decl</a>

</div>

<h5 class="subsubsection">4.10.1.1 Ref.Stmt.Decl.Item</h5>

<!-- * Ref.Stmt.Decl.Item::                Statement declaring an item. -->
<p>An <dfn>item declaration statement</dfn> has a syntactic form identical to an item
declaration within a module. Declaring an item &ndash; a function, iterator,
object, type or module &ndash; locally within a statement block is simply a way of
restricting its scope to a narrow region containing all of its uses; it is
otherwise identical in meaning to declaring the item outside the statement
block.

   <p>Note: there is no implicit capture of the function's dynamic environment when
declaring a function-local item.

<div class="node">
<a name="Ref.Stmt.Decl.Slot"></a>
<a name="Ref_002eStmt_002eDecl_002eSlot"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eStmt_002eDecl_002eItem">Ref.Stmt.Decl.Item</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eStmt_002eDecl">Ref.Stmt.Decl</a>

</div>

<h5 class="subsubsection">4.10.1.2 Ref.Stmt.Decl.Slot</h5>

<!-- * Ref.Stmt.Decl.Slot::                Statement declaring an slot. -->
<p><a name="index-Local-slot-140"></a><a name="index-Variable_002c-see-_0040i_007bLocal-slot_007d-141"></a><a name="index-Type-inference-142"></a>
A <code>slot declaration statement</code> has one one of two forms:

     <ul>
<li><code>let</code> <var>pattern</var> <var>optional-init</var>;
<li><code>let</code> <var>pattern</var> : <var>type</var> <var>optional-init</var>;
</ul>

   <p>Where <var>type</var> is a type expression, <var>pattern</var> is an irrefutable pattern
(often just the name of a single slot), and <var>optional-init</var> is an optional
initializer. If present, the initializer consists of either an equals sign
(<code>=</code>) or move operator (<code>&lt;-</code>), followed by an expression.

   <p>Both forms introduce a new slot into the containing block scope. The new slot
is visible across the entire scope, but is initialized only at the point
following the declaration statement.

   <p>The former form, with no type annotation, causes the compiler to infer the
static type of the slot through unification with the types of values assigned
to the slot in the remaining code in the block scope. Inference only occurs on
frame-local slots, not argument slots. Function, iterator and object
signatures must always declared types for all argument slots. 
See <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a>.

<div class="node">
<a name="Ref.Stmt.Expr"></a>
<a name="Ref_002eStmt_002eExpr"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eStmt_002eDecl">Ref.Stmt.Decl</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eStmt">Ref.Stmt</a>

</div>

<h4 class="subsection">4.10.2 Ref.Stmt.Expr</h4>

<!-- * Ref.Stmt.Expr::                Statement evaluating an expression -->
<p><a name="index-Expression-statement-143"></a>
An <dfn>expression statement</dfn> is one that evaluates an expression and drops
its result. The purpose of an expression statement is often to cause the side
effects of the expression's evaluation.

<div class="node">
<a name="Ref.Expr"></a>
<a name="Ref_002eExpr"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eRun">Ref.Run</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eStmt">Ref.Stmt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.11 Ref.Expr</h3>

<!-- * Ref.Expr::               Parsed and primitive expressions. -->
<p><a name="index-Expressions-144"></a>

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eExpr_002eCopy">Ref.Expr.Copy</a>:                Expression for copying a value. 
<li><a accesskey="2" href="#Ref_002eExpr_002eCall">Ref.Expr.Call</a>:                Expression for calling a function. 
<li><a accesskey="3" href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a>:                Expression for binding arguments to functions. 
<li><a accesskey="4" href="#Ref_002eExpr_002eRet">Ref.Expr.Ret</a>:                 Expression for stopping and producing a value. 
<!-- * Ref.Expr.Be::                 Expression for stopping and executing a tail call. -->
<li><a accesskey="5" href="#Ref_002eExpr_002ePut">Ref.Expr.Put</a>:                 Expression for pausing and producing a value. 
<li><a accesskey="6" href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a>:                Expression for causing task failure. 
<li><a accesskey="7" href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a>:                 Expression for logging values to diagnostic buffers. 
<li><a accesskey="8" href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a>:                Expression for logging values during failure. 
<li><a accesskey="9" href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a>:               Expression for simple conditional looping. 
<li><a href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a>:               Expression for terminating a loop. 
<li><a href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a>:                Expression for terminating a single loop iteration. 
<li><a href="#Ref_002eExpr_002eFor">Ref.Expr.For</a>:                 Expression for looping over strings and vectors. 
<li><a href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a>:             Expression for looping via an iterator. 
<li><a href="#Ref_002eExpr_002eIf">Ref.Expr.If</a>:                  Expression for simple conditional branching. 
<li><a href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>:                 Expression for complex conditional branching. 
<li><a href="#Ref_002eExpr_002eProve">Ref.Expr.Prove</a>:               Expression for static assertion of typestate. 
<li><a href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a>:               Expression for dynamic assertion of typestate. 
<li><a href="#Ref_002eExpr_002eClaim">Ref.Expr.Claim</a>:               Expression for static (unsafe) or dynamic assertion of typestate. 
<li><a href="#Ref_002eExpr_002eAssert">Ref.Expr.Assert</a>:              Expression for halting the program if a boolean condition fails to hold. 
<li><a href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a>:             Expression for dynamic testing of typestate. 
<li><a href="#Ref_002eExpr_002eAnonObj">Ref.Expr.AnonObj</a>:             Expression for extending objects with additional methods. 
</ul>

<div class="node">
<a name="Ref.Expr.Copy"></a>
<a name="Ref_002eExpr_002eCopy"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eCall">Ref.Expr.Call</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.1 Ref.Expr.Copy</h4>

<!-- * Ref.Expr.Copy::                Expression for copying a value. -->
<p><a name="index-Copy-expression-145"></a><a name="index-Assignment-operator_002c-see-_0040i_007bCopy-expression_007d-146"></a>
A <dfn>copy expression</dfn> consists of an <em>lval</em> followed by an equals-sign
(<code>=</code>) and a primitive expression. See <a href="#Ref_002eExpr">Ref.Expr</a>.

   <p>Executing a copy expression causes the value denoted by the expression &ndash;
either a value or a primitive combination of values &ndash; to be copied into the
memory location denoted by the <em>lval</em>.

   <p>A copy may entail the adjustment of reference counts, execution of destructors,
or similar adjustments in order to respect the path through the memory graph
implied by the <code>lval</code>, as well as any existing value held in the memory
being written-to. All such adjustment is automatic and implied by the <code>=</code>
operator.

   <p>An example of three different copy expressions:
<pre class="example">     x = y;
     x.y = z;
     x.y = z + 2;
</pre>
   <div class="node">
<a name="Ref.Expr.Call"></a>
<a name="Ref_002eExpr_002eCall"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eCopy">Ref.Expr.Copy</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.2 Ref.Expr.Call</h4>

<!-- * Ref.Expr.Call::               Expression for calling a function. -->
<p><a name="index-Call-expression-147"></a><a name="index-Function-calls-148"></a>
A <dfn>call expression</dfn> invokes a function, providing a tuple of input slots
and an reference slot to serve as the function's output, bound to the <var>lval</var>
on the right hand side of the call. If the function eventually returns, then
the expression completes.

   <p>A call expression statically requires that the precondition declared in the
callee's signature is satisfied by the expression prestate. In this way,
typestates propagate through function boundaries. See <a href="#Ref_002eTypestate">Ref.Typestate</a>.

   <p>An example of a call expression:
<pre class="example">     let x: int = add(1, 2);
</pre>
   <div class="node">
<a name="Ref.Expr.Bind"></a>
<a name="Ref_002eExpr_002eBind"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eRet">Ref.Expr.Ret</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eCall">Ref.Expr.Call</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.3 Ref.Expr.Bind</h4>

<!-- * Ref.Expr.Bind::          Expression for binding arguments to functions. -->
<p><a name="index-Bind-expression-149"></a><a name="index-Closures-150"></a><a name="index-Currying-151"></a>
A <dfn>bind expression</dfn> constructs a new function from an existing
function.<a rel="footnote" href="#fn-13" name="fnd-13"><sup>13</sup></a> The new function has zero or more of its
arguments <em>bound</em> into a new, hidden boxed tuple that holds the
bindings. For each concrete argument passed in the <code>bind</code> expression, the
corresponding parameter in the existing function is <em>omitted</em> as a
parameter of the new function. For each argument passed the placeholder symbol
<code>_</code> in the <code>bind</code> expression, the corresponding parameter of the
existing function is <em>retained</em> as a parameter of the new function.

   <p>Any subsequent invocation of the new function with residual arguments causes
invocation of the existing function with the combination of bound arguments
and residual arguments that was specified during the binding.

   <p>An example of a <code>bind</code> expression:
<pre class="example">     fn add(x: int, y: int) -&gt; int {
         ret x + y;
     }
     type single_param_fn = fn(int) -&gt; int;
     
     let add4: single_param_fn = bind add(4, _);
     
     let add5: single_param_fn = bind add(_, 5);
     
     assert (add(4,5) == add4(5));
     assert (add(4,5) == add5(4));
     
</pre>
   <p>A <code>bind</code> expression generally stores a copy of the bound arguments in the
hidden, boxed tuple, owned by the resulting first-class function. For each
bound slot in the bound function's signature, space is allocated in the hidden
tuple and populated with a copy of the bound value.

   <p>The <code>bind</code> expression is a lightweight mechanism for simulating the more
elaborate construct of <em>lexical closures</em> that exist in other
languages. Rust has no support for lexical closures, but many realistic uses
of them can be achieved with <code>bind</code> expressions.

<div class="node">
<a name="Ref.Expr.Ret"></a>
<a name="Ref_002eExpr_002eRet"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002ePut">Ref.Expr.Put</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.4 Ref.Expr.Ret</h4>

<!-- * Ref.Expr.Ret::                Expression for stopping and producing a value. -->
<p><a name="index-Return-expression-152"></a>
Executing a <code>ret</code> expression<a rel="footnote" href="#fn-14" name="fnd-14"><sup>14</sup></a>  copies a value into the output
slot of the current function, destroys the current function activation frame,
and transfers control to the caller frame.

   <p>An example of a <code>ret</code> expression:
<pre class="example">     fn max(a: int, b: int) -&gt; int {
        if (a &gt; b) {
           ret a;
        }
        ret b;
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Put"></a>
<a name="Ref_002eExpr_002ePut"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eRet">Ref.Expr.Ret</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.5 Ref.Expr.Put</h4>

<!-- * Ref.Expr.Put::                Expression for pausing and producing a value. -->
<p><a name="index-Put-expression-153"></a><a name="index-Iterators-154"></a>
Executing a <code>put</code> expression copies a value into the output slot of the
current iterator, suspends execution of the current iterator, and transfers
control to the current put-recipient frame.

   <p>A <code>put</code> expression is only valid within an iterator.  <a rel="footnote" href="#fn-15" name="fnd-15"><sup>15</sup></a> The current put-recipient will
eventually resume the suspended iterator containing the <code>put</code> expression,
either continuing execution after the <code>put</code> expression, or terminating its
execution and destroying the iterator frame.

<div class="node">
<a name="Ref.Expr.Fail"></a>
<a name="Ref_002eExpr_002eFail"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002ePut">Ref.Expr.Put</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.6 Ref.Expr.Fail</h4>

<!-- * Ref.Expr.Fail::               Expression for causing task failure. -->
<p><a name="index-Fail-expression-155"></a><a name="index-Failure-156"></a><a name="index-Unwinding-157"></a>
Executing a <code>fail</code> expression causes a task to enter the <em>failing</em>
state. In the <em>failing</em> state, a task unwinds its stack, destroying all
frames and freeing all resources until it reaches its entry frame, at which
point it halts execution in the <em>dead</em> state.

<div class="node">
<a name="Ref.Expr.Log"></a>
<a name="Ref_002eExpr_002eLog"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.7 Ref.Expr.Log</h4>

<!-- * Ref.Expr.Log::                Expression for logging values to diagnostic buffers. -->
<p><a name="index-Log-expression-158"></a><a name="index-Logging-159"></a>
Executing a <code>log</code> expression may, depending on runtime configuration,
cause a value to be appended to an internal diagnostic logging buffer provided
by the runtime or emitted to a system console. Log expressions are enabled or
disabled dynamically at run-time on a per-task and per-item
basis. See <a href="#Ref_002eRun_002eLog">Ref.Run.Log</a>.

<pre class="example"></pre>
   <div class="node">
<a name="Ref.Expr.Note"></a>
<a name="Ref_002eExpr_002eNote"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.8 Ref.Expr.Note</h4>

<!-- * Ref.Expr.Note::                Expression for logging values during failure. -->
<p><a name="index-Note-expression-160"></a><a name="index-Logging-161"></a><a name="index-Unwinding-162"></a><a name="index-Failure-163"></a>
A <code>note</code> expression has no effect during normal execution. The purpose of
a <code>note</code> expression is to provide additional diagnostic information to the
logging subsystem during task failure. See <a href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a>. Using <code>note</code>
expressions, normal diagnostic logging can be kept relatively sparse, while
still providing verbose diagnostic &ldquo;back-traces&rdquo; when a task fails.

   <p>When a task is failing, control frames <em>unwind</em> from the innermost frame
to the outermost, and from the innermost lexical block within an unwinding
frame to the outermost. When unwinding a lexical block, the runtime processes
all the <code>note</code> expressions in the block sequentially, from the first
expression of the block to the last.  During processing, a <code>note</code>
expression has equivalent meaning to a <code>log</code> expression: it causes the
runtime to append the argument of the <code>note</code> to the internal logging
diagnostic buffer.

   <p>An example of a <code>note</code> expression:
<pre class="example">     fn read_file_lines(path: str) -&gt; [str] {
         note path;
         let r: [str];
         let f: file = open_read(path);
         for each (s: str in lines(f)) {
             vec::append(r,s);
         }
         ret r;
     }
</pre>
   <p>In this example, if the task fails while attempting to open or read a file,
the runtime will log the path name that was being read. If the function
completes normally, the runtime will not log the path.

   <p>A value that is marked by a <code>note</code> expression is <em>not</em> copied aside
when control passes through the <code>note</code>. In other words, if a <code>note</code>
expression notes a particular <var>lval</var>, and code after the <code>note</code>
mutates that slot, and then a subsequent failure occurs, the <em>mutated</em>
value will be logged during unwinding, <em>not</em> the original value that was
denoted by the <var>lval</var> at the moment control passed through the <code>note</code>
expression.

<div class="node">
<a name="Ref.Expr.While"></a>
<a name="Ref_002eExpr_002eWhile"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.9 Ref.Expr.While</h4>

<!-- * Ref.Expr.While::              Expression for simple conditional looping. -->
<p><a name="index-While-expression-164"></a><a name="index-Loops-165"></a><a name="index-Control_002dflow-166"></a>
A <code>while</code> expression is a loop construct. A <code>while</code> loop may be
either a simple <code>while</code> or a <code>do</code>-<code>while</code> loop.

   <p>In the case of a simple <code>while</code>, the loop begins by evaluating the
boolean loop conditional expression. If the loop conditional expression
evaluates to <code>true</code>, the loop body block executes and control returns to
the loop conditional expression. If the loop conditional expression evaluates
to <code>false</code>, the <code>while</code> expression completes.

   <p>In the case of a <code>do</code>-<code>while</code>, the loop begins with an execution of
the loop body. After the loop body executes, it evaluates the loop conditional
expression. If it evaluates to <code>true</code>, control returns to the beginning
of the loop body. If it evaluates to <code>false</code>, control exits the loop.

   <p>An example of a simple <code>while</code> expression:
<pre class="example">     while (i &lt; 10) {
         print("hello\n");
         i = i + 1;
     }
</pre>
   <p>An example of a <code>do</code>-<code>while</code> expression:
<pre class="example">     do {
         print("hello\n");
         i = i + 1;
     } while (i &lt; 10);
</pre>
   <div class="node">
<a name="Ref.Expr.Break"></a>
<a name="Ref_002eExpr_002eBreak"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.10 Ref.Expr.Break</h4>

<!-- * Ref.Expr.Break::              Expression for terminating a loop. -->
<p><a name="index-Break-expression-167"></a><a name="index-Loops-168"></a><a name="index-Control_002dflow-169"></a>
Executing a <code>break</code> expression immediately terminates the innermost loop
enclosing it. It is only permitted in the body of a loop.

<div class="node">
<a name="Ref.Expr.Cont"></a>
<a name="Ref_002eExpr_002eCont"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eFor">Ref.Expr.For</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.11 Ref.Expr.Cont</h4>

<!-- * Ref.Expr.Cont::               Expression for terminating a single loop iteration. -->
<p><a name="index-Continue-expression-170"></a><a name="index-Loops-171"></a><a name="index-Control_002dflow-172"></a>
Executing a <code>cont</code> expression immediately terminates the current iteration
of the innermost loop enclosing it, returning control to the loop
<em>head</em>. In the case of a <code>while</code> loop, the head is the conditional
expression controlling the loop. In the case of a <code>for</code> or <code>for
each</code> loop, the head is the iterator or vector-element increment controlling the
loop.

   <p>A <code>cont</code> expression is only permitted in the body of a loop.

<div class="node">
<a name="Ref.Expr.For"></a>
<a name="Ref_002eExpr_002eFor"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.12 Ref.Expr.For</h4>

<!-- * Ref.Expr.For::                Expression for looping over strings and vectors. -->
<p><a name="index-For-expression-173"></a><a name="index-Loops-174"></a><a name="index-Control_002dflow-175"></a>
A <dfn>for loop</dfn> is controlled by a vector or string. The for loop
bounds-checks the underlying sequence <em>once</em> when initiating the loop,
then repeatedly copies each value of the underlying sequence into the element
variable, executing the loop body once per copy.

   <p>Example a for loop:
<pre class="example">     let v: [foo] = [a, b, c];
     
     for (foo e in v) {
         bar(e);
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Foreach"></a>
<a name="Ref_002eExpr_002eForeach"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eIf">Ref.Expr.If</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eFor">Ref.Expr.For</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.13 Ref.Expr.Foreach</h4>

<!-- * Ref.Expr.Foreach::           Expression for general conditional looping. -->
<p><a name="index-Foreach-expression-176"></a><a name="index-Loops-177"></a><a name="index-Control_002dflow-178"></a>
An <dfn>foreach loop</dfn> is denoted by the <code>for each</code> keywords, and is
controlled by an iterator. The loop executes once for each value <code>put</code> by
the iterator.  When the iterator returns or fails, the loop terminates.

   <p>Example of a foreach loop:
<pre class="example">     let txt: str;
     let lines: [str];
     for each (s: str in str::split(txt, "\n")) {
         vec::push(lines, s);
     }
</pre>
   <div class="node">
<a name="Ref.Expr.If"></a>
<a name="Ref_002eExpr_002eIf"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.14 Ref.Expr.If</h4>

<!-- * Ref.Expr.If::                 Expression for simple conditional branching. -->
<p><a name="index-If-expression-179"></a><a name="index-Control_002dflow-180"></a>
An <code>if</code> expression is a conditional branch in program control. The form of
an <code>if</code> expression is a parenthesized condition expression, followed by a
consequent block, any number of <code>else if</code> conditions and blocks, and an
optional trailing <code>else</code> block. The condition expressions must have type
<code>bool</code>. If a condition expression evaluates to <code>true</code>, the
consequent block is executed and any subsequent <code>else if</code> or <code>else</code>
block is skipped. If a condition expression evaluates to <code>false</code>, the
consequent block is skipped and any subsequent <code>else if</code> condition is
evaluated. If all <code>if</code> and <code>else if</code> conditions evaluate to <code>false</code>
then any <code>else</code> block is executed.

<div class="node">
<a name="Ref.Expr.Alt"></a>
<a name="Ref_002eExpr_002eAlt"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eProve">Ref.Expr.Prove</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eIf">Ref.Expr.If</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.15 Ref.Expr.Alt</h4>

<!-- * Ref.Expr.Alt::                Expression for complex conditional branching. -->
<p><a name="index-Alt-expression-181"></a><a name="index-Control_002dflow-182"></a><a name="index-Switch-expression_002c-see-_0040i_007bAlt-expression_007d-183"></a>
An <code>alt</code> expression is a multi-directional branch in program control. 
There are two kinds of <code>alt</code> expression: pattern <code>alt</code> expressions
and <code>alt type</code> expressions.

   <p>The form of each kind of <code>alt</code> is similar: an initial <em>head</em> that
describes the criteria for branching, followed by a sequence of zero or more
<em>arms</em>, each of which describes a <em>case</em> and provides a <em>block</em>
of expressions associated with the case. When an <code>alt</code> is executed,
control enters the head, determines which of the cases to branch to, branches
to the block associated with the chosen case, and then proceeds to the
expression following the <code>alt</code> when the case block completes.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eExpr_002eAlt_002ePat">Ref.Expr.Alt.Pat</a>:           Expression for branching on pattern matches. 
<li><a accesskey="2" href="#Ref_002eExpr_002eAlt_002eType">Ref.Expr.Alt.Type</a>:          Expression for branching on types. 
</ul>

<div class="node">
<a name="Ref.Expr.Alt.Pat"></a>
<a name="Ref_002eExpr_002eAlt_002ePat"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eAlt_002eType">Ref.Expr.Alt.Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>

</div>

<h5 class="subsubsection">4.11.15.1 Ref.Expr.Alt.Pat</h5>

<!-- * Ref.Expr.Alt.Pat::            Expression for branching on pattern matches. -->
<p><a name="index-Pattern-alt-expression-184"></a><a name="index-Control_002dflow-185"></a>
A pattern <code>alt</code> expression branches on a <em>pattern</em>. The exact form of
matching that occurs depends on the pattern. Patterns consist of some
combination of literals, tag constructors, variable binding specifications and
placeholders (<code>_</code>). A pattern <code>alt</code> has a parenthesized <em>head
expression</em>, which is the value to compare to the patterns. The type of the
patterns must equal the type of the head expression.

   <p>To execute a pattern <code>alt</code> expression, first the head expression is
evaluated, then its value is sequentially compared to the patterns in the arms
until a match is found. The first arm with a matching <code>case</code> pattern is
chosen as the branch target of the <code>alt</code>, any variables bound by the
pattern are assigned to local slots in the arm's block, and control enters the
block.

   <p>An example of a pattern <code>alt</code> expression:

<pre class="example">     type list&lt;X&gt; = tag(nil, cons(X, @list&lt;X&gt;));
     
     let x: list&lt;int&gt; = cons(10, cons(11, nil));
     
     alt (x) {
         case (cons(a, cons(b, _))) {
             process_pair(a,b);
         }
         case (cons(v=10, _)) {
             process_ten(v);
         }
         case (_) {
             fail;
         }
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Alt.Type"></a>
<a name="Ref_002eExpr_002eAlt_002eType"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eAlt_002ePat">Ref.Expr.Alt.Pat</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>

</div>

<h5 class="subsubsection">4.11.15.2 Ref.Expr.Alt.Type</h5>

<!-- * Ref.Expr.Alt.Type::           Expression for branching on type. -->
<p><a name="index-Type-alt-expression-186"></a><a name="index-Control_002dflow-187"></a>
An <code>alt type</code> expression is similar to a pattern <code>alt</code>, but branches
on the <em>type</em> of its head expression, rather than the value. The head
expression of an <code>alt type</code> expression must be of type <code>any</code>, and the
arms of the expression are slot patterns rather than value patterns. Control
branches to the arm with a <code>case</code> that matches the <em>actual type</em> of
the value in the <code>any</code>.

   <p>An example of an <code>alt type</code> expression:

<pre class="example">     let x: any = foo();
     
     alt type (x) {
         case (int i) {
             ret i;
         }
         case (list&lt;int&gt; li) {
             ret int_list_sum(li);
         }
         case (list&lt;X&gt; lx) {
             ret list_len(lx);
         }
         case (_) {
             ret 0;
         }
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Prove"></a>
<a name="Ref_002eExpr_002eProve"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.16 Ref.Expr.Prove</h4>

<!-- * Ref.Expr.Prove::              Expression for static assertion of typestate. -->
<p><a name="index-Prove-expression-188"></a><a name="index-Typestate-system-189"></a>
A <code>prove</code> expression has no run-time effect. Its purpose is to statically
check (and document) that its argument constraint holds at its expression entry
point. If its argument typestate does not hold, under the typestate algorithm,
the program containing it will fail to compile.

<div class="node">
<a name="Ref.Expr.Check"></a>
<a name="Ref_002eExpr_002eCheck"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eClaim">Ref.Expr.Claim</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eProve">Ref.Expr.Prove</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.17 Ref.Expr.Check</h4>

<!-- * Ref.Expr.Check::              Expression for dynamic assertion of typestate. -->
<p><a name="index-Check-expression-190"></a><a name="index-Typestate-system-191"></a>
A <code>check</code> expression connects dynamic assertions made at run-time to the
static typestate system. A <code>check</code> expression takes a constraint to check
at run-time. If the constraint holds at run-time, control passes through the
<code>check</code> and on to the next expression in the enclosing block. If the
condition fails to hold at run-time, the <code>check</code> expression behaves as a
<code>fail</code> expression.

   <p>The typestate algorithm is built around <code>check</code> expressions, and in
particular the fact that control <em>will not pass</em> a check expression with a
condition that fails to hold. The typestate algorithm can therefore assume
that the (static) postcondition of a <code>check</code> expression includes the
checked constraint itself. From there, the typestate algorithm can perform
dataflow calculations on subsequent expressions, propagating conditions forward
and statically comparing implied states and their
specifications. See <a href="#Ref_002eTypestate">Ref.Typestate</a>.

<pre class="example">     pure fn even(x: int) -&gt; bool {
         ret x &amp; 1 == 0;
     }
     
     fn print_even(x: int) : even(x) {
         print(x);
     }
     
     fn test() {
         let y: int = 8;
     
         // Cannot call print_even(y) here.
     
         check even(y);
     
         // Can call print_even(y) here, since even(y) now holds.
         print_even(y);
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Claim"></a>
<a name="Ref_002eExpr_002eClaim"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eAssert">Ref.Expr.Assert</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.18 Ref.Expr.Claim</h4>

<!-- * Ref.Expr.Claim::              Expression for static (unsafe) or dynamic assertion of typestate. -->
<p><a name="index-Claim-expression-192"></a><a name="index-Typestate-system-193"></a>
A <code>claim</code> expression is an unsafe variant on a <code>check</code> expression
that is not actually checked at runtime. Thus, using a <code>claim</code> implies a
proof obligation to ensure&mdash;without compiler assistance&mdash;that an assertion
always holds.

   <p>Setting a runtime flag can turn all <code>claim</code> expressions
into <code>check</code> expressions in a compiled Rust program, but the default is to not check the assertion
contained in a <code>claim</code>. The idea behind <code>claim</code> is that performance profiling might identify a
few bottlenecks in the code where actually checking a given callee's predicate
is too expensive; <code>claim</code> allows the code to typecheck without removing
the predicate check at every other call site.

<div class="node">
<a name="Ref.Expr.IfCheck"></a>
<a name="Ref_002eExpr_002eIfCheck"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eAnonObj">Ref.Expr.AnonObj</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eAssert">Ref.Expr.Assert</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.19 Ref.Expr.IfCheck</h4>

<!-- * Ref.Expr.IfCheck::            Expression for dynamic testing of typestate. -->
<p><a name="index-If-check-expression-194"></a><a name="index-Typestate-system-195"></a><a name="index-Control_002dflow-196"></a>
An <code>if check</code> expression combines a <code>if</code> expression and a <code>check</code>
expression in an indivisible unit that can be used to build more complex
conditional control-flow than the <code>check</code> expression affords.

   <p>In fact, <code>if check</code> is a &ldquo;more primitive&rdquo; expression than <code>check</code>;
instances of the latter can be rewritten as instances of the former. The
following two examples are equivalent:

   <pre class="sp">

</pre>
Example using <code>check</code>:
<pre class="example">     check even(x);
     print_even(x);
</pre>
   <pre class="sp">

</pre>
Equivalent example using <code>if check</code>:
<pre class="example">     if check even(x) {
         print_even(x);
     } else {
         fail;
     }
</pre>
   <div class="node">
<a name="Ref.Expr.Assert"></a>
<a name="Ref_002eExpr_002eAssert"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eClaim">Ref.Expr.Claim</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.20 Ref.Expr.Assert</h4>

<!-- * Ref.Expr.Assert::            Expression that halts the program if a boolean condition fails to hold. -->
<p><a name="index-Assertions-197"></a>
An <code>assert</code> expression is similar to a <code>check</code> expression, except
the condition may be any boolean-typed expression, and the compiler makes no
use of the knowledge that the condition holds if the program continues to
execute after the <code>assert</code>.

<div class="node">
<a name="Ref.Expr.AnonObj"></a>
<a name="Ref_002eExpr_002eAnonObj"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eExpr">Ref.Expr</a>

</div>

<h4 class="subsection">4.11.21 Ref.Expr.AnonObj</h4>

<!-- * Ref.Expr.AnonObj::           Expression that extends an object with additional methods. -->
<p><a name="index-Anonymous-objects-198"></a>
An <em>anonymous object</em> expression extends an existing object with methods.

<div class="node">
<a name="Ref.Run"></a>
<a name="Ref_002eRun"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eExpr">Ref.Expr</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Reference">Reference</a>

</div>

<h3 class="section">4.12 Ref.Run</h3>

<!-- * Ref.Run::                     Organization of runtime services. -->
<p><a name="index-Runtime-library-199"></a>
The Rust <dfn>runtime</dfn> is a relatively compact collection of C and Rust code
that provides fundamental services and datatypes to all Rust tasks at
run-time. It is smaller and simpler than many modern language runtimes. It is
tightly integrated into the language's execution model of memory, tasks,
communication, reflection, logging and signal handling.

<ul class="menu">
<li><a accesskey="1" href="#Ref_002eRun_002eMem">Ref.Run.Mem</a>:                  Runtime memory management service. 
<li><a accesskey="2" href="#Ref_002eRun_002eType">Ref.Run.Type</a>:                 Runtime built-in type services. 
<li><a accesskey="3" href="#Ref_002eRun_002eComm">Ref.Run.Comm</a>:                 Runtime communication service. 
<li><a accesskey="4" href="#Ref_002eRun_002eLog">Ref.Run.Log</a>:                  Runtime logging system. 
<li><a accesskey="5" href="#Ref_002eRun_002eSig">Ref.Run.Sig</a>:                  Runtime signal handler. 
</ul>

<div class="node">
<a name="Ref.Run.Mem"></a>
<a name="Ref_002eRun_002eMem"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eRun_002eType">Ref.Run.Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eRun">Ref.Run</a>

</div>

<h4 class="subsection">4.12.1 Ref.Run.Mem</h4>

<!-- * Ref.Run.Mem::                 Runtime memory management service. -->
<p><a name="index-Memory-allocation-200"></a>
The runtime memory-management system is based on a <em>service-provider
interface</em>, through which the runtime requests blocks of memory from its
environment and releases them back to its environment when they are no longer
in use. The default implementation of the service-provider interface consists
of the C runtime functions <code>malloc</code> and <code>free</code>.

   <p>The runtime memory-management system in turn supplies Rust tasks with
facilities for allocating, extending and releasing stacks, as well as
allocating and freeing boxed values.

<div class="node">
<a name="Ref.Run.Type"></a>
<a name="Ref_002eRun_002eType"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eRun_002eComm">Ref.Run.Comm</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eRun_002eMem">Ref.Run.Mem</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eRun">Ref.Run</a>

</div>

<h4 class="subsection">4.12.2 Ref.Run.Type</h4>

<!-- * Ref.Run.Mem::                 Runtime built-in type services. -->
<p><a name="index-Built_002din-types-201"></a>
The runtime provides C and Rust code to assist with various built-in types,
such as vectors, strings, bignums, and the low level communication system
(ports, channels, tasks).

   <p>Support for other built-in types such as simple types, tuples, records, and
tags is open-coded by the Rust compiler.

<div class="node">
<a name="Ref.Run.Comm"></a>
<a name="Ref_002eRun_002eComm"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eRun_002eLog">Ref.Run.Log</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eRun_002eType">Ref.Run.Type</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eRun">Ref.Run</a>

</div>

<h4 class="subsection">4.12.3 Ref.Run.Comm</h4>

<!-- * Ref.Run.Comm::                Runtime communication service. -->
<p><a name="index-Communication-202"></a><a name="index-Process-203"></a><a name="index-Thread-204"></a>
The runtime provides code to manage inter-task communication.  This includes
the system of task-lifecycle state transitions depending on the contents of
queues, as well as code to copy values between queues and their recipients and
to serialize values for transmission over operating-system inter-process
communication facilities.

<div class="node">
<a name="Ref.Run.Log"></a>
<a name="Ref_002eRun_002eLog"></a>
<p><hr>
Next:&nbsp;<a rel="next" accesskey="n" href="#Ref_002eRun_002eSig">Ref.Run.Sig</a>,
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eRun_002eComm">Ref.Run.Comm</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eRun">Ref.Run</a>

</div>

<h4 class="subsection">4.12.4 Ref.Run.Log</h4>

<!-- * Ref.Run.Log::                 Runtime logging system. -->
<p><a name="index-Logging-205"></a>
The runtime contains a system for directing logging expressions to a logging
console and/or internal logging buffers. See <a href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a>.  Logging
expressions can be enabled or disabled via a two-dimensional filtering process:

     <ul>
     <pre class="sp">
     
     </pre>
     <li>By Item

     <p>Each <em>item</em> (module, function, iterator, object, type) in Rust has a
static path within its crate module, and can have logging enabled or
disabled on a path-prefix basis.

     <pre class="sp">
     
     </pre>
     <li>By Task

     <p>Each <em>task</em> in a running Rust program has a unique ownership relation
through the task ownership tree, and can have logging enabled or disabled on
an ownership-ancestry basis. 
</ul>

   <p>Logging is integrated into the language for efficiency reasons, as well as the
need to filter logs based on these two built-in dimensions.

<div class="node">
<a name="Ref.Run.Sig"></a>
<a name="Ref_002eRun_002eSig"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Ref_002eRun_002eLog">Ref.Run.Log</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Ref_002eRun">Ref.Run</a>

</div>

<h4 class="subsection">4.12.5 Ref.Run.Sig</h4>

<!-- * Ref.Run.Sig::               Runtime signal handler. -->
<p><a name="index-Signals-206"></a>
The runtime signal-handling system is driven by a signal-dispatch table and a
signal queue associated with each task. Sending a signal to a task inserts the
signal into the task's signal queue and marks the task as having a pending
signal. At the next scheduling opportunity, the runtime processes signals in
the task's queue using its dispatch table. The signal queue memory is charged
to the task; if the queue grows too big, the task will fail.

<!-- ############################################################ -->
<!-- end main body of nodes -->
<!-- ############################################################ -->
<div class="node">
<a name="Index"></a>
<p><hr>
Previous:&nbsp;<a rel="previous" accesskey="p" href="#Reference">Reference</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="#Top">Top</a>

</div>

<h2 class="chapter">5 Index</h2>

<ul class="index-cp" compact>
<li><a href="#index-Alt-expression-181">Alt expression</a>: <a href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a></li>
<li><a href="#index-Alt-type-expression-90">Alt type expression</a>: <a href="#Ref_002eType_002eAny">Ref.Type.Any</a></li>
<li><a href="#index-Anonymous-objects-198">Anonymous objects</a>: <a href="#Ref_002eExpr_002eAnonObj">Ref.Expr.AnonObj</a></li>
<li><a href="#index-Any-type-88">Any type</a>: <a href="#Ref_002eType_002eAny">Ref.Type.Any</a></li>
<li><a href="#index-Array-types_002c-see-_0040i_007bVector-types_007d-117">Array types, see <i>Vector types</i></a>: <a href="#Ref_002eType_002eVec">Ref.Type.Vec</a></li>
<li><a href="#index-Assertions-197">Assertions</a>: <a href="#Ref_002eExpr_002eAssert">Ref.Expr.Assert</a></li>
<li><a href="#index-Assertions_002c-see-_0040i_007bCheck-statement_007d-137">Assertions, see <i>Check statement</i></a>: <a href="#Ref_002eTypestate_002eCheck">Ref.Typestate.Check</a></li>
<li><a href="#index-Assignment-operator_002c-see-_0040i_007bCopy-expression_007d-146">Assignment operator, see <i>Copy expression</i></a>: <a href="#Ref_002eExpr_002eCopy">Ref.Expr.Copy</a></li>
<li><a href="#index-Attributes-22">Attributes</a>: <a href="#Ref_002eComp_002eAttr">Ref.Comp.Attr</a></li>
<li><a href="#index-Big-integer-type-106">Big integer type</a>: <a href="#Ref_002eType_002eBig">Ref.Type.Big</a></li>
<li><a href="#index-Binary-token-9">Binary token</a>: <a href="#Ref_002eLex_002eNum">Ref.Lex.Num</a></li>
<li><a href="#index-Bind-expression-149">Bind expression</a>: <a href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a></li>
<li><a href="#index-Blocked_002c-task-state-50">Blocked, task state</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Boolean-type-104">Boolean type</a>: <a href="#Ref_002eType_002ePrim">Ref.Type.Prim</a></li>
<li><a href="#index-Box-37">Box</a>: <a href="#Ref_002eMem_002eBox">Ref.Mem.Box</a></li>
<li><a href="#index-Box-25">Box</a>: <a href="#Ref_002eMem">Ref.Mem</a></li>
<li><a href="#index-Break-expression-167">Break expression</a>: <a href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a></li>
<li><a href="#index-Built_002din-types-201">Built-in types</a>: <a href="#Ref_002eRun_002eType">Ref.Run.Type</a></li>
<li><a href="#index-Call-expression-147">Call expression</a>: <a href="#Ref_002eExpr_002eCall">Ref.Expr.Call</a></li>
<li><a href="#index-Channel-43">Channel</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Character-token-12">Character token</a>: <a href="#Ref_002eLex_002eText">Ref.Lex.Text</a></li>
<li><a href="#index-Character-type-109">Character type</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Character-type-103">Character type</a>: <a href="#Ref_002eType_002ePrim">Ref.Type.Prim</a></li>
<li><a href="#index-Check-expression-190">Check expression</a>: <a href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a></li>
<li><a href="#index-Check-statement-136">Check statement</a>: <a href="#Ref_002eTypestate_002eCheck">Ref.Typestate.Check</a></li>
<li><a href="#index-Claim-expression-192">Claim expression</a>: <a href="#Ref_002eExpr_002eClaim">Ref.Expr.Claim</a></li>
<li><a href="#index-Closures-150">Closures</a>: <a href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a></li>
<li><a href="#index-Communication-202">Communication</a>: <a href="#Ref_002eRun_002eComm">Ref.Run.Comm</a></li>
<li><a href="#index-Communication-64">Communication</a>: <a href="#Ref_002eTask_002eRecv">Ref.Task.Recv</a></li>
<li><a href="#index-Communication-61">Communication</a>: <a href="#Ref_002eTask_002eSend">Ref.Task.Send</a></li>
<li><a href="#index-Communication-41">Communication</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Compilation-model-20">Compilation model</a>: <a href="#Ref_002eComp">Ref.Comp</a></li>
<li><a href="#index-Condition-130">Condition</a>: <a href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a></li>
<li><a href="#index-Constrained-types-123">Constrained types</a>: <a href="#Ref_002eType_002eConstr">Ref.Type.Constr</a></li>
<li><a href="#index-Constraint-129">Constraint</a>: <a href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a></li>
<li><a href="#index-Continue-expression-170">Continue expression</a>: <a href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a></li>
<li><a href="#index-Control_002dflow-196">Control-flow</a>: <a href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a></li>
<li><a href="#index-Control_002dflow-187">Control-flow</a>: <a href="#Ref_002eExpr_002eAlt_002eType">Ref.Expr.Alt.Type</a></li>
<li><a href="#index-Control_002dflow-185">Control-flow</a>: <a href="#Ref_002eExpr_002eAlt_002ePat">Ref.Expr.Alt.Pat</a></li>
<li><a href="#index-Control_002dflow-182">Control-flow</a>: <a href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a></li>
<li><a href="#index-Control_002dflow-180">Control-flow</a>: <a href="#Ref_002eExpr_002eIf">Ref.Expr.If</a></li>
<li><a href="#index-Control_002dflow-178">Control-flow</a>: <a href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a></li>
<li><a href="#index-Control_002dflow-175">Control-flow</a>: <a href="#Ref_002eExpr_002eFor">Ref.Expr.For</a></li>
<li><a href="#index-Control_002dflow-172">Control-flow</a>: <a href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a></li>
<li><a href="#index-Control_002dflow-169">Control-flow</a>: <a href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a></li>
<li><a href="#index-Control_002dflow-166">Control-flow</a>: <a href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a></li>
<li><a href="#index-Control_002dflow-graph-127">Control-flow graph</a>: <a href="#Ref_002eTypestate_002eCFG">Ref.Typestate.CFG</a></li>
<li><a href="#index-Copy-expression-145">Copy expression</a>: <a href="#Ref_002eExpr_002eCopy">Ref.Expr.Copy</a></li>
<li><a href="#index-Crate-21">Crate</a>: <a href="#Ref_002eComp_002eCrate">Ref.Comp.Crate</a></li>
<li><a href="#index-Currying-151">Currying</a>: <a href="#Ref_002eExpr_002eBind">Ref.Expr.Bind</a></li>
<li><a href="#index-Dead_002c-task-state-52">Dead, task state</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Decimal-token-8">Decimal token</a>: <a href="#Ref_002eLex_002eNum">Ref.Lex.Num</a></li>
<li><a href="#index-Declaration-statement-139">Declaration statement</a>: <a href="#Ref_002eStmt_002eDecl">Ref.Stmt.Decl</a></li>
<li><a href="#index-Dereference-operator-38">Dereference operator</a>: <a href="#Ref_002eMem_002eBox">Ref.Mem.Box</a></li>
<li><a href="#index-Dynamic-type_002c-see-_0040i_007bAny-type_007d-89">Dynamic type, see <i>Any type</i></a>: <a href="#Ref_002eType_002eAny">Ref.Type.Any</a></li>
<li><a href="#index-Escape-sequence-13">Escape sequence</a>: <a href="#Ref_002eLex_002eText">Ref.Lex.Text</a></li>
<li><a href="#index-Exporting-names-74">Exporting names</a>: <a href="#Ref_002eItem_002eMod_002eExport">Ref.Item.Mod.Export</a></li>
<li><a href="#index-Exporting-names-70">Exporting names</a>: <a href="#Ref_002eItem_002eMod">Ref.Item.Mod</a></li>
<li><a href="#index-Expression-statement-143">Expression statement</a>: <a href="#Ref_002eStmt_002eExpr">Ref.Stmt.Expr</a></li>
<li><a href="#index-Expressions-144">Expressions</a>: <a href="#Ref_002eExpr">Ref.Expr</a></li>
<li><a href="#index-Fail-expression-155">Fail expression</a>: <a href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a></li>
<li><a href="#index-Failing_002c-task-state-51">Failing, task state</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Failure-163">Failure</a>: <a href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a></li>
<li><a href="#index-Failure-156">Failure</a>: <a href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a></li>
<li><a href="#index-Floating_002dpoint-token-10">Floating-point token</a>: <a href="#Ref_002eLex_002eNum">Ref.Lex.Num</a></li>
<li><a href="#index-Floating_002dpoint-types-102">Floating-point types</a>: <a href="#Ref_002eType_002ePrim">Ref.Type.Prim</a></li>
<li><a href="#index-Floating_002dpoint-types-99">Floating-point types</a>: <a href="#Ref_002eType_002eFloat">Ref.Type.Float</a></li>
<li><a href="#index-Floating_002dpoint-types-92">Floating-point types</a>: <a href="#Ref_002eType_002eMach">Ref.Type.Mach</a></li>
<li><a href="#index-For-expression-173">For expression</a>: <a href="#Ref_002eExpr_002eFor">Ref.Expr.For</a></li>
<li><a href="#index-Foreach-expression-176">Foreach expression</a>: <a href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a></li>
<li><a href="#index-Foreach-expression-82">Foreach expression</a>: <a href="#Ref_002eItem_002eIter">Ref.Item.Iter</a></li>
<li><a href="#index-Function-calls-148">Function calls</a>: <a href="#Ref_002eExpr_002eCall">Ref.Expr.Call</a></li>
<li><a href="#index-Function-types-120">Function types</a>: <a href="#Ref_002eType_002eFn">Ref.Type.Fn</a></li>
<li><a href="#index-Functions-76">Functions</a>: <a href="#Ref_002eItem_002eFn">Ref.Item.Fn</a></li>
<li><a href="#index-Hard-failure-54">Hard failure</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Heap-29">Heap</a>: <a href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a></li>
<li><a href="#index-Hex-token-7">Hex token</a>: <a href="#Ref_002eLex_002eNum">Ref.Lex.Num</a></li>
<li><a href="#index-Identifier-token-3">Identifier token</a>: <a href="#Ref_002eLex_002eIdent">Ref.Lex.Ident</a></li>
<li><a href="#index-If-check-expression-194">If check expression</a>: <a href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a></li>
<li><a href="#index-If-expression-179">If expression</a>: <a href="#Ref_002eExpr_002eIf">Ref.Expr.If</a></li>
<li><a href="#index-Importing-names-72">Importing names</a>: <a href="#Ref_002eItem_002eMod_002eImport">Ref.Item.Mod.Import</a></li>
<li><a href="#index-Importing-names-69">Importing names</a>: <a href="#Ref_002eItem_002eMod">Ref.Item.Mod</a></li>
<li><a href="#index-Integer-types-105">Integer types</a>: <a href="#Ref_002eType_002eBig">Ref.Type.Big</a></li>
<li><a href="#index-Integer-types-101">Integer types</a>: <a href="#Ref_002eType_002ePrim">Ref.Type.Prim</a></li>
<li><a href="#index-Integer-types-96">Integer types</a>: <a href="#Ref_002eType_002eInt">Ref.Type.Int</a></li>
<li><a href="#index-Integer-types-93">Integer types</a>: <a href="#Ref_002eType_002eMach">Ref.Type.Mach</a></li>
<li><a href="#index-Item-65">Item</a>: <a href="#Ref_002eItem">Ref.Item</a></li>
<li><a href="#index-Item-27">Item</a>: <a href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a></li>
<li><a href="#index-Iterator-types-121">Iterator types</a>: <a href="#Ref_002eType_002eIter">Ref.Type.Iter</a></li>
<li><a href="#index-Iterators-154">Iterators</a>: <a href="#Ref_002eExpr_002ePut">Ref.Expr.Put</a></li>
<li><a href="#index-Iterators-79">Iterators</a>: <a href="#Ref_002eItem_002eIter">Ref.Item.Iter</a></li>
<li><a href="#index-Keywords-4">Keywords</a>: <a href="#Ref_002eLex_002eKey">Ref.Lex.Key</a></li>
<li><a href="#index-Lexical-structure-1">Lexical structure</a>: <a href="#Ref_002eLex">Ref.Lex</a></li>
<li><a href="#index-Lifecycle-of-task-47">Lifecycle of task</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Local-slot-140">Local slot</a>: <a href="#Ref_002eStmt_002eDecl_002eSlot">Ref.Stmt.Decl.Slot</a></li>
<li><a href="#index-Local-slot-35">Local slot</a>: <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a></li>
<li><a href="#index-Log-expression-158">Log expression</a>: <a href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a></li>
<li><a href="#index-Logging-205">Logging</a>: <a href="#Ref_002eRun_002eLog">Ref.Run.Log</a></li>
<li><a href="#index-Logging-161">Logging</a>: <a href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a></li>
<li><a href="#index-Logging-159">Logging</a>: <a href="#Ref_002eExpr_002eLog">Ref.Expr.Log</a></li>
<li><a href="#index-Loops-177">Loops</a>: <a href="#Ref_002eExpr_002eForeach">Ref.Expr.Foreach</a></li>
<li><a href="#index-Loops-174">Loops</a>: <a href="#Ref_002eExpr_002eFor">Ref.Expr.For</a></li>
<li><a href="#index-Loops-171">Loops</a>: <a href="#Ref_002eExpr_002eCont">Ref.Expr.Cont</a></li>
<li><a href="#index-Loops-168">Loops</a>: <a href="#Ref_002eExpr_002eBreak">Ref.Expr.Break</a></li>
<li><a href="#index-Loops-165">Loops</a>: <a href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a></li>
<li><a href="#index-Machine-types-91">Machine types</a>: <a href="#Ref_002eType_002eMach">Ref.Type.Mach</a></li>
<li><a href="#index-Machine_002ddependent-types-98">Machine-dependent types</a>: <a href="#Ref_002eType_002eFloat">Ref.Type.Float</a></li>
<li><a href="#index-Machine_002ddependent-types-95">Machine-dependent types</a>: <a href="#Ref_002eType_002eInt">Ref.Type.Int</a></li>
<li><a href="#index-Memory-allocation-200">Memory allocation</a>: <a href="#Ref_002eRun_002eMem">Ref.Run.Mem</a></li>
<li><a href="#index-Memory-model-24">Memory model</a>: <a href="#Ref_002eMem">Ref.Mem</a></li>
<li><a href="#index-Message-passing-44">Message passing</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Messages-63">Messages</a>: <a href="#Ref_002eTask_002eRecv">Ref.Task.Recv</a></li>
<li><a href="#index-Messages-60">Messages</a>: <a href="#Ref_002eTask_002eSend">Ref.Task.Send</a></li>
<li><a href="#index-Module-item-68">Module item</a>: <a href="#Ref_002eItem_002eMod">Ref.Item.Mod</a></li>
<li><a href="#index-Module-item-67">Module item</a>: <a href="#Ref_002eItem">Ref.Item</a></li>
<li><a href="#index-Names-of-items-or-slots-17">Names of items or slots</a>: <a href="#Ref_002ePath">Ref.Path</a></li>
<li><a href="#index-Note-expression-160">Note expression</a>: <a href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a></li>
<li><a href="#index-Number-token-6">Number token</a>: <a href="#Ref_002eLex_002eNum">Ref.Lex.Num</a></li>
<li><a href="#index-Object-constructors-84">Object constructors</a>: <a href="#Ref_002eItem_002eObj">Ref.Item.Obj</a></li>
<li><a href="#index-Object-types-122">Object types</a>: <a href="#Ref_002eType_002eObj">Ref.Type.Obj</a></li>
<li><a href="#index-Objects-83">Objects</a>: <a href="#Ref_002eItem_002eObj">Ref.Item.Obj</a></li>
<li><a href="#index-Operator-16">Operator</a>: <a href="#Ref_002eLex_002eSym">Ref.Lex.Sym</a></li>
<li><a href="#index-Ownership-32">Ownership</a>: <a href="#Ref_002eMem_002eOwn">Ref.Mem.Own</a></li>
<li><a href="#index-Path-name-18">Path name</a>: <a href="#Ref_002ePath">Ref.Path</a></li>
<li><a href="#index-Pattern-alt-expression-184">Pattern alt expression</a>: <a href="#Ref_002eExpr_002eAlt_002ePat">Ref.Expr.Alt.Pat</a></li>
<li><a href="#index-Points-126">Points</a>: <a href="#Ref_002eTypestate_002ePoint">Ref.Typestate.Point</a></li>
<li><a href="#index-Port-42">Port</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Postcondition-132">Postcondition</a>: <a href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a></li>
<li><a href="#index-Poststate-135">Poststate</a>: <a href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a></li>
<li><a href="#index-Precondition-131">Precondition</a>: <a href="#Ref_002eTypestate_002eCond">Ref.Typestate.Cond</a></li>
<li><a href="#index-Predicate-128">Predicate</a>: <a href="#Ref_002eTypestate_002eConstr">Ref.Typestate.Constr</a></li>
<li><a href="#index-Predicate-78">Predicate</a>: <a href="#Ref_002eItem_002ePred">Ref.Item.Pred</a></li>
<li><a href="#index-Preemption-56">Preemption</a>: <a href="#Ref_002eTask_002eSched">Ref.Task.Sched</a></li>
<li><a href="#index-Prestate-134">Prestate</a>: <a href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a></li>
<li><a href="#index-Primitive-types-100">Primitive types</a>: <a href="#Ref_002eType_002ePrim">Ref.Type.Prim</a></li>
<li><a href="#index-Process-203">Process</a>: <a href="#Ref_002eRun_002eComm">Ref.Run.Comm</a></li>
<li><a href="#index-Process-40">Process</a>: <a href="#Ref_002eTask">Ref.Task</a></li>
<li><a href="#index-Prove-expression-188">Prove expression</a>: <a href="#Ref_002eExpr_002eProve">Ref.Expr.Prove</a></li>
<li><a href="#index-Put-each-expression-81">Put each expression</a>: <a href="#Ref_002eItem_002eIter">Ref.Item.Iter</a></li>
<li><a href="#index-Put-expression-153">Put expression</a>: <a href="#Ref_002eExpr_002ePut">Ref.Expr.Put</a></li>
<li><a href="#index-Put-expression-80">Put expression</a>: <a href="#Ref_002eItem_002eIter">Ref.Item.Iter</a></li>
<li><a href="#index-Receive-call-62">Receive call</a>: <a href="#Ref_002eTask_002eRecv">Ref.Task.Recv</a></li>
<li><a href="#index-Receive-expression-46">Receive expression</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Record-types-113">Record types</a>: <a href="#Ref_002eType_002eRec">Ref.Type.Rec</a></li>
<li><a href="#index-Reference-slot-36">Reference slot</a>: <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a></li>
<li><a href="#index-Reserved-5">Reserved</a>: <a href="#Ref_002eLex_002eRes">Ref.Lex.Res</a></li>
<li><a href="#index-Return-expression-152">Return expression</a>: <a href="#Ref_002eExpr_002eRet">Ref.Expr.Ret</a></li>
<li><a href="#index-Running_002c-task-state-49">Running, task state</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Runtime-library-199">Runtime library</a>: <a href="#Ref_002eRun">Ref.Run</a></li>
<li><a href="#index-Scheduling-55">Scheduling</a>: <a href="#Ref_002eTask_002eSched">Ref.Task.Sched</a></li>
<li><a href="#index-Scheduling-48">Scheduling</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Send-call-59">Send call</a>: <a href="#Ref_002eTask_002eSend">Ref.Task.Send</a></li>
<li><a href="#index-Send-expression-45">Send expression</a>: <a href="#Ref_002eTask_002eComm">Ref.Task.Comm</a></li>
<li><a href="#index-Shared-box-30">Shared box</a>: <a href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a></li>
<li><a href="#index-Signals-206">Signals</a>: <a href="#Ref_002eRun_002eSig">Ref.Run.Sig</a></li>
<li><a href="#index-Slot-34">Slot</a>: <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a></li>
<li><a href="#index-Slot-26">Slot</a>: <a href="#Ref_002eMem">Ref.Mem</a></li>
<li><a href="#index-Slots_002c-function-input-and-output-77">Slots, function input and output</a>: <a href="#Ref_002eItem_002eFn">Ref.Item.Fn</a></li>
<li><a href="#index-Soft-failure-53">Soft failure</a>: <a href="#Ref_002eTask_002eLife">Ref.Task.Life</a></li>
<li><a href="#index-Spawn-expression-58">Spawn expression</a>: <a href="#Ref_002eTask_002eSpawn">Ref.Task.Spawn</a></li>
<li><a href="#index-Stack-33">Stack</a>: <a href="#Ref_002eMem_002eSlot">Ref.Mem.Slot</a></li>
<li><a href="#index-Stack-28">Stack</a>: <a href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a></li>
<li><a href="#index-Statements-138">Statements</a>: <a href="#Ref_002eStmt">Ref.Stmt</a></li>
<li><a href="#index-String-token-11">String token</a>: <a href="#Ref_002eLex_002eText">Ref.Lex.Text</a></li>
<li><a href="#index-String-type-108">String type</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Structure-types_002c-see-_0040i_007bRecord-types_007d-114">Structure types, see <i>Record types</i></a>: <a href="#Ref_002eType_002eRec">Ref.Type.Rec</a></li>
<li><a href="#index-Switch-expression_002c-see-_0040i_007bAlt-expression_007d-183">Switch expression, see <i>Alt expression</i></a>: <a href="#Ref_002eExpr_002eAlt">Ref.Expr.Alt</a></li>
<li><a href="#index-Symbol-15">Symbol</a>: <a href="#Ref_002eLex_002eSym">Ref.Lex.Sym</a></li>
<li><a href="#index-Syntax-extension-23">Syntax extension</a>: <a href="#Ref_002eComp_002eSyntax">Ref.Comp.Syntax</a></li>
<li><a href="#index-Tag-types-118">Tag types</a>: <a href="#Ref_002eType_002eTag">Ref.Type.Tag</a></li>
<li><a href="#index-Tag-types-86">Tag types</a>: <a href="#Ref_002eItem_002eTag">Ref.Item.Tag</a></li>
<li><a href="#index-Task-39">Task</a>: <a href="#Ref_002eTask">Ref.Task</a></li>
<li><a href="#index-Task_002dlocal-box-31">Task-local box</a>: <a href="#Ref_002eMem_002eAlloc">Ref.Mem.Alloc</a></li>
<li><a href="#index-Text-types-107">Text types</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Thread-204">Thread</a>: <a href="#Ref_002eRun_002eComm">Ref.Run.Comm</a></li>
<li><a href="#index-Token-2">Token</a>: <a href="#Ref_002eLex">Ref.Lex</a></li>
<li><a href="#index-Tuple-types-115">Tuple types</a>: <a href="#Ref_002eType_002eTup">Ref.Type.Tup</a></li>
<li><a href="#index-Type-alt-expression-186">Type alt expression</a>: <a href="#Ref_002eExpr_002eAlt_002eType">Ref.Expr.Alt.Type</a></li>
<li><a href="#index-Type-definitions-85">Type definitions</a>: <a href="#Ref_002eItem_002eType">Ref.Item.Type</a></li>
<li><a href="#index-Type-inference-142">Type inference</a>: <a href="#Ref_002eStmt_002eDecl_002eSlot">Ref.Stmt.Decl.Slot</a></li>
<li><a href="#index-Type-parameters-66">Type parameters</a>: <a href="#Ref_002eItem">Ref.Item</a></li>
<li><a href="#index-Type-parameters-19">Type parameters</a>: <a href="#Ref_002ePath">Ref.Path</a></li>
<li><a href="#index-Type-type-124">Type type</a>: <a href="#Ref_002eType_002eType">Ref.Type.Type</a></li>
<li><a href="#index-Types-87">Types</a>: <a href="#Ref_002eType">Ref.Type</a></li>
<li><a href="#index-Typestate-133">Typestate</a>: <a href="#Ref_002eTypestate_002eState">Ref.Typestate.State</a></li>
<li><a href="#index-Typestate-system-195">Typestate system</a>: <a href="#Ref_002eExpr_002eIfCheck">Ref.Expr.IfCheck</a></li>
<li><a href="#index-Typestate-system-193">Typestate system</a>: <a href="#Ref_002eExpr_002eClaim">Ref.Expr.Claim</a></li>
<li><a href="#index-Typestate-system-191">Typestate system</a>: <a href="#Ref_002eExpr_002eCheck">Ref.Expr.Check</a></li>
<li><a href="#index-Typestate-system-189">Typestate system</a>: <a href="#Ref_002eExpr_002eProve">Ref.Expr.Prove</a></li>
<li><a href="#index-Typestate-system-125">Typestate system</a>: <a href="#Ref_002eTypestate">Ref.Typestate</a></li>
<li><a href="#index-UCS_002d4-111">UCS-4</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Unicode-110">Unicode</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Unicode-14">Unicode</a>: <a href="#Ref_002eLex_002eText">Ref.Lex.Text</a></li>
<li><a href="#index-Union-types_002c-see-_0040i_007bTag-types_007d-119">Union types, see <i>Tag types</i></a>: <a href="#Ref_002eType_002eTag">Ref.Type.Tag</a></li>
<li><a href="#index-Unwinding-162">Unwinding</a>: <a href="#Ref_002eExpr_002eNote">Ref.Expr.Note</a></li>
<li><a href="#index-Unwinding-157">Unwinding</a>: <a href="#Ref_002eExpr_002eFail">Ref.Expr.Fail</a></li>
<li><a href="#index-UTF_002d8-112">UTF-8</a>: <a href="#Ref_002eType_002eText">Ref.Type.Text</a></li>
<li><a href="#index-Variable_002c-see-_0040i_007bLocal-slot_007d-141">Variable, see <i>Local slot</i></a>: <a href="#Ref_002eStmt_002eDecl_002eSlot">Ref.Stmt.Decl.Slot</a></li>
<li><a href="#index-Vector-types-116">Vector types</a>: <a href="#Ref_002eType_002eVec">Ref.Type.Vec</a></li>
<li><a href="#index-Visibility-control-75">Visibility control</a>: <a href="#Ref_002eItem_002eMod_002eExport">Ref.Item.Mod.Export</a></li>
<li><a href="#index-Visibility-control-73">Visibility control</a>: <a href="#Ref_002eItem_002eMod_002eImport">Ref.Item.Mod.Import</a></li>
<li><a href="#index-Visibility-control-71">Visibility control</a>: <a href="#Ref_002eItem_002eMod">Ref.Item.Mod</a></li>
<li><a href="#index-While-expression-164">While expression</a>: <a href="#Ref_002eExpr_002eWhile">Ref.Expr.While</a></li>
<li><a href="#index-Word-types-97">Word types</a>: <a href="#Ref_002eType_002eInt">Ref.Type.Int</a></li>
<li><a href="#index-Word-types-94">Word types</a>: <a href="#Ref_002eType_002eMach">Ref.Type.Mach</a></li>
<li><a href="#index-Yielding-control-57">Yielding control</a>: <a href="#Ref_002eTask_002eSched">Ref.Task.Sched</a></li>
   </ul><div class="footnote">
<hr>
<a name="texinfo-footnotes-in-document"></a><h4>Footnotes</h4><p class="footnote"><small>[<a name="fn-1" href="#fnd-1">1</a>]</small> Unicode Standard Annex
#31: Unicode Identifier and Pattern Syntax</p>

   <p class="footnote"><small>[<a name="fn-2" href="#fnd-2">2</a>]</small> This identifier syntax is a superset of the identifier syntaxes of C
and Java, and is modeled on Python PEP #3131, which formed the definition of
identifiers in Python 3.0 and later.</p>

   <p class="footnote"><small>[<a name="fn-3" href="#fnd-3">3</a>]</small> A crate is somewhat analogous to an
<em>assembly</em> in the ECMA-335 CLI model, a <em>library</em> in the SML/NJ
Compilation Manager, a <em>unit</em> in the Owens and Flatt module system, or a
<em>configuration</em> in Mesa.</p>

   <p class="footnote"><small>[<a name="fn-4" href="#fnd-4">4</a>]</small> Attributes in Rust are modeled on Attributes in
ECMA-335, C#</p>

   <p class="footnote"><small>[<a name="fn-5" href="#fnd-5">5</a>]</small> It may help to remember nautical terminology
when differentiating channels from ports.  Many different waterways &ndash;
channels &ndash; may lead to the same port.</p>

   <p class="footnote"><small>[<a name="fn-6" href="#fnd-6">6</a>]</small> A Rust <code>uint</code> is analogous to a C99
<code>uintptr_t</code>.</p>

   <p class="footnote"><small>[<a name="fn-7" href="#fnd-7">7</a>]</small> A Rust <code>int</code> is analogous to a C99
<code>intptr_t</code>.</p>

   <p class="footnote"><small>[<a name="fn-8" href="#fnd-8">8</a>]</small> The &ldquo;nil&rdquo; value <code>()</code> is <em>not</em> a sentinel
&ldquo;null pointer&rdquo; value for reference slots; the &ldquo;nil&rdquo; type is the implicit
return type from functions otherwise lacking a return type, and can be used in
other contexts (such as message-sending or type-parametric code) as a
zero-size type.</p>

   <p class="footnote"><small>[<a name="fn-9" href="#fnd-9">9</a>]</small> A Rust <code>big</code> is analogous to a Lisp
bignum or a Python long integer.</p>

   <p class="footnote"><small>[<a name="fn-10" href="#fnd-10">10</a>]</small> The record type-constructor is analogous to the <code>struct</code>
type-constructor in the Algol/C family, the <em>record</em> types of the ML
family, or the <em>structure</em> types of the Lisp family.</p>

   <p class="footnote"><small>[<a name="fn-11" href="#fnd-11">11</a>]</small> The <code>tag</code> type is analogous to a <code>data</code> constructor
declaration in ML or a <em>pick ADT</em> in Limbo.</p>

   <p class="footnote"><small>[<a name="fn-12" href="#fnd-12">12</a>]</small> A <code>check</code> expression is similar to an <code>assert</code>
call in a C program, with the significant difference that the Rust compiler
<em>tracks</em> the constraint that each <code>check</code> expression
enforces. Naturally, <code>check</code> expressions cannot be omitted from a
&ldquo;production build&rdquo; of a Rust program the same way <code>asserts</code> are
frequently disabled in deployed C programs.</p>

   <p class="footnote"><small>[<a name="fn-13" href="#fnd-13">13</a>]</small> The <code>bind</code> expression is analogous to the <code>bind</code>
expression in the Sather language.</p>

   <p class="footnote"><small>[<a name="fn-14" href="#fnd-14">14</a>]</small> A <code>ret</code> expression is analogous
to a <code>return</code> expression in the C family.</p>

   <p class="footnote"><small>[<a name="fn-15" href="#fnd-15">15</a>]</small> A
<code>put</code> expression is analogous to a <code>yield</code> expression in the CLU, and
Sather languages, or in more recent languages providing a &ldquo;generator&rdquo;
facility, such as Python, Javascript or C#. Like the generators of CLU and
Sather but <em>unlike</em> these later languages, Rust's iterators reside on the
stack and obey a strict stack discipline.</p>

   <hr></div>

</body></html>

