<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN" "http://www.w3.org/TR/REC-html40/strict.dtd">

<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>vec</title><link rel="stylesheet" type="text/css" href="../styles/main.css"><script language=JavaScript src="../javascript/main.js"></script><script language=JavaScript src="../javascript/prettify.js"></script><script language=JavaScript src="../javascript/searchdata.js"></script></head><body class="ContentPage" onLoad="NDOnLoad();prettyPrint();"><script language=JavaScript><!--
if (browserType) {document.write("<div class=" + browserType + ">");if (browserVer) {document.write("<div class=" + browserVer + ">"); }}// --></script>

<!--  Generated by Natural Docs, version 1.51 -->
<!--  http://www.naturaldocs.org  -->

<!-- saved from url=(0026)http://www.naturaldocs.org -->




<div id=Content><div class="CModule"><div class=CTopic id=MainTopic><h1 class=CTitle><a name="vec"></a>vec</h1><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SMain"><td class=SEntry><a href="#vec" >vec</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#vec.Types" >Types</a></td><td class=SDescription></td></tr><tr class="SType SIndent2 SMarked"><td class=SEntry><a href="#vec.init_op" id=link1 onMouseOver="ShowTip(event, 'tt1', 'link1')" onMouseOut="HideTip('tt1')">init_op</a></td><td class=SDescription>A function used to initialize the elements of a vector.</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#vec.Predicates" >Predicates</a></td><td class=SDescription></td></tr><tr class="SPredicate SIndent2 SMarked"><td class=SEntry><a href="#vec.is_empty" id=link2 onMouseOver="ShowTip(event, 'tt2', 'link2')" onMouseOut="HideTip('tt2')">is_empty</a></td><td class=SDescription>Returns true if a vector contains no elements.</td></tr><tr class="SPredicate SIndent2"><td class=SEntry><a href="#vec.is_not_empty" id=link3 onMouseOver="ShowTip(event, 'tt3', 'link3')" onMouseOut="HideTip('tt3')">is_not_empty</a></td><td class=SDescription>Returns true if a vector contains some elements.</td></tr><tr class="SPredicate SIndent2 SMarked"><td class=SEntry><a href="#vec.same_length" id=link4 onMouseOver="ShowTip(event, 'tt4', 'link4')" onMouseOut="HideTip('tt4')">same_length</a></td><td class=SDescription>Returns true if two vectors have the same length</td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#vec.Functions" >Functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.reserve" id=link5 onMouseOver="ShowTip(event, 'tt5', 'link5')" onMouseOut="HideTip('tt5')">reserve</a></td><td class=SDescription>Reserves capacity for `n` elements in the given vector.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.len" id=link6 onMouseOver="ShowTip(event, 'tt6', 'link6')" onMouseOut="HideTip('tt6')">len</a></td><td class=SDescription>Returns the length of a vector</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.init_fn" id=link7 onMouseOver="ShowTip(event, 'tt7', 'link7')" onMouseOut="HideTip('tt7')">init_fn</a></td><td class=SDescription>Creates and initializes an immutable vector.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.init_fn_mut" id=link8 onMouseOver="ShowTip(event, 'tt8', 'link8')" onMouseOut="HideTip('tt8')">init_fn_mut</a></td><td class=SDescription>Creates and initializes a mutable vector.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.init_elt" id=link9 onMouseOver="ShowTip(event, 'tt9', 'link9')" onMouseOut="HideTip('tt9')">init_elt</a></td><td class=SDescription>Creates and initializes an immutable vector.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.init_elt_mut" id=link10 onMouseOver="ShowTip(event, 'tt10', 'link10')" onMouseOut="HideTip('tt10')">init_elt_mut</a></td><td class=SDescription>Creates and initializes a mutable vector.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.to_mut" id=link11 onMouseOver="ShowTip(event, 'tt11', 'link11')" onMouseOut="HideTip('tt11')">to_mut</a></td><td class=SDescription>Produces a mutable vector from an immutable vector.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.from_mut" id=link12 onMouseOver="ShowTip(event, 'tt12', 'link12')" onMouseOut="HideTip('tt12')">from_mut</a></td><td class=SDescription>Produces an immutable vector from a mutable vector.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.head" id=link13 onMouseOver="ShowTip(event, 'tt13', 'link13')" onMouseOut="HideTip('tt13')">head</a></td><td class=SDescription>Returns the first element of a vector</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.tail" id=link14 onMouseOver="ShowTip(event, 'tt14', 'link14')" onMouseOut="HideTip('tt14')">tail</a></td><td class=SDescription>Returns all but the first element of a vector</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.init" id=link15 onMouseOver="ShowTip(event, 'tt15', 'link15')" onMouseOut="HideTip('tt15')">init</a></td><td class=SDescription>Returns all but the last elemnt of a vector</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.last" id=link16 onMouseOver="ShowTip(event, 'tt16', 'link16')" onMouseOut="HideTip('tt16')">last</a></td><td class=SDescription>Returns the last element of a vector</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.last_total" id=link17 onMouseOver="ShowTip(event, 'tt17', 'link17')" onMouseOut="HideTip('tt17')">last_total</a></td><td class=SDescription>Returns the last element of a non-empty vector `v`</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.slice" id=link18 onMouseOver="ShowTip(event, 'tt18', 'link18')" onMouseOut="HideTip('tt18')">slice</a></td><td class=SDescription>Returns a copy of the elements from [`start`..`end`) from `v`.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.slice_mut" id=link19 onMouseOver="ShowTip(event, 'tt19', 'link19')" onMouseOut="HideTip('tt19')">slice_mut</a></td><td class=SDescription>Returns a copy of the elements from [`start`..`end`) from `v`.</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.shift" id=link20 onMouseOver="ShowTip(event, 'tt20', 'link20')" onMouseOut="HideTip('tt20')">shift</a></td><td class=SDescription>Removes the first element from a vector and return it</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.pop" id=link21 onMouseOver="ShowTip(event, 'tt21', 'link21')" onMouseOut="HideTip('tt21')">pop</a></td><td class=SDescription>Remove the last element from a vector and return it</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.grow" id=link22 onMouseOver="ShowTip(event, 'tt22', 'link22')" onMouseOut="HideTip('tt22')">grow</a></td><td class=SDescription>Expands a vector in place, initializing the new elements to a given value</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.grow_mut" id=link23 onMouseOver="ShowTip(event, 'tt23', 'link23')" onMouseOut="HideTip('tt23')">grow_mut</a></td><td class=SDescription>Expands a vector in place, initializing the new elements to a given value</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.grow_fn" id=link24 onMouseOver="ShowTip(event, 'tt24', 'link24')" onMouseOut="HideTip('tt24')">grow_fn</a></td><td class=SDescription>Expands a vector in place, initializing the new elements to the result of a function</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.grow_set" id=link25 onMouseOver="ShowTip(event, 'tt25', 'link25')" onMouseOut="HideTip('tt25')">grow_set</a></td><td class=SDescription>Sets the value of a vector element at a given index, growing the vector as needed</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.map" id=link26 onMouseOver="ShowTip(event, 'tt26', 'link26')" onMouseOut="HideTip('tt26')">map</a></td><td class=SDescription>Apply a function to each element of a vector and return the results</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.map_mut" id=link27 onMouseOver="ShowTip(event, 'tt27', 'link27')" onMouseOut="HideTip('tt27')">map_mut</a></td><td class=SDescription>Apply a function to each element of a mutable vector and return the results</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.map2" id=link28 onMouseOver="ShowTip(event, 'tt28', 'link28')" onMouseOut="HideTip('tt28')">map2</a></td><td class=SDescription>Apply a function to each pair of elements and return the results</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.filter_map" id=link29 onMouseOver="ShowTip(event, 'tt29', 'link29')" onMouseOut="HideTip('tt29')">filter_map</a></td><td class=SDescription>Apply a function to each element of a vector and return the results</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.filter" id=link30 onMouseOver="ShowTip(event, 'tt30', 'link30')" onMouseOut="HideTip('tt30')">filter</a></td><td class=SDescription>Construct a new vector from the elements of a vector for which some predicate holds.</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.concat" id=link31 onMouseOver="ShowTip(event, 'tt31', 'link31')" onMouseOut="HideTip('tt31')">concat</a></td><td class=SDescription>Concatenate a vector of vectors. </td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.foldl" id=link32 onMouseOver="ShowTip(event, 'tt32', 'link32')" onMouseOut="HideTip('tt32')">foldl</a></td><td class=SDescription>Reduce a vector from left to right</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.foldr" id=link33 onMouseOver="ShowTip(event, 'tt33', 'link33')" onMouseOut="HideTip('tt33')">foldr</a></td><td class=SDescription>Reduce a vector from right to left</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.any" id=link34 onMouseOver="ShowTip(event, 'tt34', 'link34')" onMouseOut="HideTip('tt34')">any</a></td><td class=SDescription>Return true if a predicate matches any elements</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.all" id=link35 onMouseOver="ShowTip(event, 'tt35', 'link35')" onMouseOut="HideTip('tt35')">all</a></td><td class=SDescription>Return true if a predicate matches all elements</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.member" id=link36 onMouseOver="ShowTip(event, 'tt36', 'link36')" onMouseOut="HideTip('tt36')">member</a></td><td class=SDescription>Return true if a vector contains an element with the given value</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.count" id=link37 onMouseOver="ShowTip(event, 'tt37', 'link37')" onMouseOut="HideTip('tt37')">count</a></td><td class=SDescription>Returns the number of elements that are equal to a given value</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.find" id=link38 onMouseOver="ShowTip(event, 'tt38', 'link38')" onMouseOut="HideTip('tt38')">find</a></td><td class=SDescription>Search for an element that matches a given predicate</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.position" id=link39 onMouseOver="ShowTip(event, 'tt39', 'link39')" onMouseOut="HideTip('tt39')">position</a></td><td class=SDescription>Find the first index containing a matching value</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.position_pred" id=link40 onMouseOver="ShowTip(event, 'tt40', 'link40')" onMouseOut="HideTip('tt40')">position_pred</a></td><td class=SDescription>Find the first index for which the value matches some predicate</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.unzip" id=link41 onMouseOver="ShowTip(event, 'tt41', 'link41')" onMouseOut="HideTip('tt41')">unzip</a></td><td class=SDescription>Convert a vector of pairs into a pair of vectors</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.zip" id=link42 onMouseOver="ShowTip(event, 'tt42', 'link42')" onMouseOut="HideTip('tt42')">zip</a></td><td class=SDescription>Convert two vectors to a vector of pairs</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.swap" id=link43 onMouseOver="ShowTip(event, 'tt43', 'link43')" onMouseOut="HideTip('tt43')">swap</a></td><td class=SDescription>Swaps two elements in a vector</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.reverse" id=link44 onMouseOver="ShowTip(event, 'tt44', 'link44')" onMouseOut="HideTip('tt44')">reverse</a></td><td class=SDescription>Reverse the order of elements in a vector, in place</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.reversed" id=link45 onMouseOver="ShowTip(event, 'tt45', 'link45')" onMouseOut="HideTip('tt45')">reversed</a></td><td class=SDescription>Returns a vector with the order of elements reversed</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.enum_chars" id=link46 onMouseOver="ShowTip(event, 'tt46', 'link46')" onMouseOut="HideTip('tt46')">enum_chars</a></td><td class=SDescription>Returns a vector containing a range of chars</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.enum_uints" id=link47 onMouseOver="ShowTip(event, 'tt47', 'link47')" onMouseOut="HideTip('tt47')">enum_uints</a></td><td class=SDescription>Returns a vector containing a range of uints</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.iter" id=link48 onMouseOver="ShowTip(event, 'tt48', 'link48')" onMouseOut="HideTip('tt48')">iter</a></td><td class=SDescription>Iterates over a vector</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.iter2" id=link49 onMouseOver="ShowTip(event, 'tt49', 'link49')" onMouseOut="HideTip('tt49')">iter2</a></td><td class=SDescription>Iterates over a vector&rsquo;s elements and indexes</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.riter" id=link50 onMouseOver="ShowTip(event, 'tt50', 'link50')" onMouseOut="HideTip('tt50')">riter</a></td><td class=SDescription>Iterates over a vector in reverse</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.riter2" id=link51 onMouseOver="ShowTip(event, 'tt51', 'link51')" onMouseOut="HideTip('tt51')">riter2</a></td><td class=SDescription>Iterates over a vector&rsquo;s elements and indexes in reverse</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#vec.permute" id=link52 onMouseOver="ShowTip(event, 'tt52', 'link52')" onMouseOut="HideTip('tt52')">permute</a></td><td class=SDescription>Iterate over all permutations of vector `v`. </td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#vec.to_ptr" id=link53 onMouseOver="ShowTip(event, 'tt53', 'link53')" onMouseOut="HideTip('tt53')">to_ptr</a></td><td class=SDescription>FIXME: We don&rsquo;t need this wrapper</td></tr><tr class="SModule"><td class=SEntry><a href="#unsafe" >unsafe</a></td><td class=SDescription></td></tr><tr class="SGroup SIndent1"><td class=SEntry><a href="#unsafe.Functions" >Functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#unsafe.from_buf" id=link54 onMouseOver="ShowTip(event, 'tt54', 'link54')" onMouseOut="HideTip('tt54')">from_buf</a></td><td class=SDescription>Constructs a vector from an unsafe pointer to a buffer</td></tr><tr class="SFunction SIndent2"><td class=SEntry><a href="#unsafe.set_len" id=link55 onMouseOver="ShowTip(event, 'tt55', 'link55')" onMouseOut="HideTip('tt55')">set_len</a></td><td class=SDescription>Sets the length of a vector</td></tr><tr class="SFunction SIndent2 SMarked"><td class=SEntry><a href="#unsafe.to_ptr" id=link56 onMouseOver="ShowTip(event, 'tt56', 'link56')" onMouseOut="HideTip('tt56')">to_ptr</a></td><td class=SDescription>Returns an unsafe pointer to the vector&rsquo;s buffer</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="vec.Types"></a>Types</h3></div></div>

<div class="CType"><div class=CTopic><h3 class=CTitle><a name="vec.init_op"></a>init_op</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>type init_op&lt;T&gt; = block(</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote><p>A function used to initialize the elements of a vector.</p></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="vec.Predicates"></a>Predicates</h3></div></div>

<div class="CPredicate"><div class=CTopic><h3 class=CTitle><a name="vec.is_empty"></a>is_empty</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn is_empty&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Returns true if a vector contains no elements.</p></div></div></div>

<div class="CPredicate"><div class=CTopic><h3 class=CTitle><a name="vec.is_not_empty"></a>is_not_empty</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn is_not_empty&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Returns true if a vector contains some elements.</p></div></div></div>

<div class="CPredicate"><div class=CTopic><h3 class=CTitle><a name="vec.same_length"></a>same_length</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn same_length&lt;T, U&gt;(</td><td class="PType  prettyprint " nowrap>xs:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>ys:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Returns true if two vectors have the same length</p></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="vec.Functions"></a>Functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.reserve"></a>reserve</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reserve&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Reserves capacity for `n` elements in the given vector.</p><p>If the capacity for `v` is already equal to or greater than the requested capacity, then no action is taken.</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>v</td><td class=CDLDescription>A vector</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>The number of elements to reserve space for</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.len"></a>len</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn len&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; uint</td></tr></table></td></tr></table></blockquote><p>Returns the length of a vector</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.init_fn"></a>init_fn</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_fn&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Creates and initializes an immutable vector.</p><p>Creates an immutable vector of size `n_elts` and initializes the elements to the value returned by the function `op`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.init_fn_mut"></a>init_fn_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_fn_mut&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote><p>Creates and initializes a mutable vector.</p><p>Creates a mutable vector of size `n_elts` and initializes the elements to the value returned by the function `op`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.init_elt"></a>init_elt</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_elt&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>t:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Creates and initializes an immutable vector.</p><p>Creates an immutable vector of size `n_elts` and initializes the elements to the value `t`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.init_elt_mut"></a>init_elt_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_elt_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>t:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote><p>Creates and initializes a mutable vector.</p><p>Creates a mutable vector of size `n_elts` and initializes the elements to the value `t`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.to_mut"></a>to_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn to_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote><p>Produces a mutable vector from an immutable vector.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.from_mut"></a>from_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn from_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Produces an immutable vector from a mutable vector.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.head"></a>head</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn head&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; T</td></tr></table></td></tr></table></blockquote><p>Returns the first element of a vector</p><h4 class=CHeading>Predicates</h4><p><a href="#vec.is_not_empty" class=LPredicate id=link57 onMouseOver="ShowTip(event, 'tt3', 'link57')" onMouseOut="HideTip('tt3')">is_not_empty</a> (v)</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.tail"></a>tail</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn tail&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Returns all but the first element of a vector</p><h4 class=CHeading>Predicates</h4><p><a href="#vec.is_not_empty" class=LPredicate id=link58 onMouseOver="ShowTip(event, 'tt3', 'link58')" onMouseOut="HideTip('tt3')">is_not_empty</a> (v)</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.init"></a>init</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Returns all but the last elemnt of a vector</p><h4 class=CHeading>Preconditions</h4><p>`v` is not empty</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.last"></a>last</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn last&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;T&gt;</td></tr></table></td></tr></table></blockquote><p>Returns the last element of a vector</p><h4 class=CHeading>Returns</h4><p>An option containing the last element of `v` if `v` is not empty, or none if `v` is empty.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.last_total"></a>last_total</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn last_total&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; T</td></tr></table></td></tr></table></blockquote><p>Returns the last element of a non-empty vector `v`</p><h4 class=CHeading>Predicates</h4><p><a href="#vec.is_not_empty" class=LPredicate id=link59 onMouseOver="ShowTip(event, 'tt3', 'link59')" onMouseOut="HideTip('tt3')">is_not_empty</a> (v)</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.slice"></a>slice</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn slice&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Returns a copy of the elements from [`start`..`end`) from `v`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.slice_mut"></a>slice_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn slice_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote><p>Returns a copy of the elements from [`start`..`end`) from `v`.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.shift"></a>shift</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn shift&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote><p>Removes the first element from a vector and return it</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.pop"></a>pop</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn pop&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote><p>Remove the last element from a vector and return it</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.grow"></a>grow</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Expands a vector in place, initializing the new elements to a given value</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>v</td><td class=CDLDescription>The vector to grow</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>The number of elements to add</td></tr><tr><td class=CDLEntry>initval</td><td class=CDLDescription>The value for the new elements</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.grow_mut"></a>grow_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Expands a vector in place, initializing the new elements to a given value</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>v</td><td class=CDLDescription>The vector to grow</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>The number of elements to add</td></tr><tr><td class=CDLEntry>initval</td><td class=CDLDescription>The value for the new elements</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.grow_fn"></a>grow_fn</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_fn&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Expands a vector in place, initializing the new elements to the result of a function</p><p>Function `init_fn` is called `n` times with the values [0..`n`)</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>v</td><td class=CDLDescription>The vector to grow</td></tr><tr><td class=CDLEntry>n</td><td class=CDLDescription>The number of elements to add</td></tr><tr><td class=CDLEntry>init_fn</td><td class=CDLDescription>A function to call to retreive each appended element&rsquo;s value</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.grow_set"></a>grow_set</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_set&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>index:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>val:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets the value of a vector element at a given index, growing the vector as needed</p><p>Sets the element at position `index` to `val`.&nbsp; If `index` is past the end of the vector, expands the vector by replicating `initval` to fill the intervening space.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.map"></a>map</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map&lt;T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote><p>Apply a function to each element of a vector and return the results</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.map_mut"></a>map_mut</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map_mut&lt;copy T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote><p>Apply a function to each element of a mutable vector and return the results</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.map2"></a>map2</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map2&lt;copy T, copy U, V&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>V,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v0:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v1:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [V]</td></tr></table></td></tr></table></blockquote><p>Apply a function to each pair of elements and return the results</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.filter_map"></a>filter_map</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn filter_map&lt;copy T, copy U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>option::t&lt;U&gt;,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote><p>Apply a function to each element of a vector and return the results</p><p>If function `f` returns `none` then that element is excluded from the resulting vector.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.filter"></a>filter</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn filter&lt;copy T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Construct a new vector from the elements of a vector for which some predicate holds.</p><p>Apply function `f` to each element of `v` and return a vector containing only those elements for which `f` returned true.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.concat"></a>concat</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn concat&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const [const T]]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Concatenate a vector of vectors.&nbsp; Flattens a vector of vectors of T into a single vector of T.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.foldl"></a>foldl</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn foldl&lt;copy T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>p: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>z:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote><p>Reduce a vector from left to right</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.foldr"></a>foldr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn foldr&lt;T, copy U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>p: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>z:&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; U</td></tr></table></td></tr></table></blockquote><p>Reduce a vector from right to left</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.any"></a>any</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn any&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Return true if a predicate matches any elements</p><p>If the vector contains no elements then false is returned.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.all"></a>all</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn all&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Return true if a predicate matches all elements</p><p>If the vector contains no elements then true is returned.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.member"></a>member</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn member&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote><p>Return true if a vector contains an element with the given value</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.count"></a>count</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn count&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; uint</td></tr></table></td></tr></table></blockquote><p>Returns the number of elements that are equal to a given value</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.find"></a>find</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn find&lt;copy T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;T&gt;</td></tr></table></td></tr></table></blockquote><p>Search for an element that matches a given predicate</p><p>Apply function `f` to each element of `v`, starting from the first.&nbsp; When function `f` returns true then an option containing the element is returned.&nbsp; If `f` matches no elements then none is returned.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.position"></a>position</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn position&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;uint&gt;</td></tr></table></td></tr></table></blockquote><p>Find the first index containing a matching value</p><h4 class=CHeading>Returns</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>option::some(uint)</td><td class=CDLDescription>The first index containing a matching value</td></tr><tr><td class=CDLEntry>option::none</td><td class=CDLDescription>No elements matched</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.position_pred"></a>position_pred</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn position_pred&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;uint&gt;</td></tr></table></td></tr></table></blockquote><p>Find the first index for which the value matches some predicate</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.unzip"></a>unzip</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn unzip&lt;copy T, copy U&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[(T, U)]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; ([T], [U])</td></tr></table></td></tr></table></blockquote><p>Convert a vector of pairs into a pair of vectors</p><p>Returns a tuple containing two vectors where the i-th element of the first vector contains the first element of the i-th tuple of the input vector, and the i-th element of the second vector contains the second element of the i-th tuple of the input vector.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.zip"></a>zip</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn zip&lt;copy T, copy U&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>u:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) : same_length(v, u) -&gt; [(T, U)]</td></tr></table></td></tr></table></blockquote><p>Convert two vectors to a vector of pairs</p><p>Returns a vector of tuples, where the i-th tuple contains contains the i-th elements from each of the input vectors.</p><h4 class=CHeading>Preconditions</h4><p><a href="#vec.same_length" class=LPredicate id=link60 onMouseOver="ShowTip(event, 'tt4', 'link60')" onMouseOut="HideTip('tt4')">same_length</a> (v, u)</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.swap"></a>swap</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn swap&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>a:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>b:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Swaps two elements in a vector</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>v</td><td class=CDLDescription>The input vector</td></tr><tr><td class=CDLEntry>a</td><td class=CDLDescription>The index of the first element</td></tr><tr><td class=CDLEntry>b</td><td class=CDLDescription>The index of the second element</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.reverse"></a>reverse</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reverse&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T]</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Reverse the order of elements in a vector, in place</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.reversed"></a>reversed</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reversed&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Returns a vector with the order of elements reversed</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.enum_chars"></a>enum_chars</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn enum_chars(</td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>u8,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>u8</td><td class="PAfterParameters  prettyprint "nowrap>) : u8::le(start, end) -&gt; [char]</td></tr></table></td></tr></table></blockquote><p>Returns a vector containing a range of chars</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.enum_uints"></a>enum_uints</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn enum_uints(</td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) : uint::le(start, end) -&gt; [uint]</td></tr></table></td></tr></table></blockquote><p>Returns a vector containing a range of uints</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.iter"></a>iter</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn iter&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Iterates over a vector</p><p>Iterates over vector `v` and, for each element, calls function `f` with the element&rsquo;s value.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.iter2"></a>iter2</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn iter2&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(uint, T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Iterates over a vector&rsquo;s elements and indexes</p><p>Iterates over vector `v` and, for each element, calls function `f` with the element&rsquo;s value and index.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.riter"></a>riter</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn riter&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Iterates over a vector in reverse</p><p>Iterates over vector `v` and, for each element, calls function `f` with the element&rsquo;s value.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.riter2"></a>riter2</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn riter2&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(uint, T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Iterates over a vector&rsquo;s elements and indexes in reverse</p><p>Iterates over vector `v` and, for each element, calls function `f` with the element&rsquo;s value and index.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.permute"></a>permute</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn permute&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>put:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block([T])</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Iterate over all permutations of vector `v`.&nbsp;  Permutations are produced in lexicographic order with respect to the order of elements in `v` (so if `v` is sorted then the permutations are lexicographically sorted).</p><p>The total number of permutations produced is `len(v)!`.&nbsp;  If `v` contains repeated elements, then some permutations are repeated.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="vec.to_ptr"></a>to_ptr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn to_ptr&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; *T</td></tr></table></td></tr></table></blockquote><p>FIXME: We don&rsquo;t need this wrapper</p></div></div></div>

<div class="CModule"><div class=CTopic><h2 class=CTitle><a name="unsafe"></a>unsafe</h2><div class=CBody><!--START_ND_SUMMARY--><div class=Summary><div class=STitle>Summary</div><div class=SBorder><table border=0 cellspacing=0 cellpadding=0 class=STable><tr class="SGroup"><td class=SEntry><a href="#unsafe.Functions" >Functions</a></td><td class=SDescription></td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#unsafe.from_buf" id=link61 onMouseOver="ShowTip(event, 'tt54', 'link61')" onMouseOut="HideTip('tt54')">from_buf</a></td><td class=SDescription>Constructs a vector from an unsafe pointer to a buffer</td></tr><tr class="SFunction SIndent1"><td class=SEntry><a href="#unsafe.set_len" id=link62 onMouseOver="ShowTip(event, 'tt55', 'link62')" onMouseOut="HideTip('tt55')">set_len</a></td><td class=SDescription>Sets the length of a vector</td></tr><tr class="SFunction SIndent1 SMarked"><td class=SEntry><a href="#unsafe.to_ptr" id=link63 onMouseOver="ShowTip(event, 'tt56', 'link63')" onMouseOut="HideTip('tt56')">to_ptr</a></td><td class=SDescription>Returns an unsafe pointer to the vector&rsquo;s buffer</td></tr></table></div></div><!--END_ND_SUMMARY--></div></div></div>

<div class="CGroup"><div class=CTopic><h3 class=CTitle><a name="unsafe.Functions"></a>Functions</h3></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="unsafe.from_buf"></a>from_buf</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn from_buf&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>ptr:&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>elts:&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote><p>Constructs a vector from an unsafe pointer to a buffer</p><h4 class=CHeading>Parameters</h4><table border=0 cellspacing=0 cellpadding=0 class=CDescriptionList><tr><td class=CDLEntry>ptr</td><td class=CDLDescription>An unsafe pointer to a buffer of `T`</td></tr><tr><td class=CDLEntry>elts</td><td class=CDLDescription>The number of elements in the buffer</td></tr></table></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="unsafe.set_len"></a>set_len</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn set_len&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>new_len:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote><p>Sets the length of a vector</p><p>This well explicitly set the size of the vector, without actually modifing its buffers, so it is up to the caller to ensure that the vector is actually the specified size.</p></div></div></div>

<div class="CFunction"><div class=CTopic><h3 class=CTitle><a name="unsafe.to_ptr"></a>to_ptr</h3><div class=CBody><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn to_ptr&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; *T</td></tr></table></td></tr></table></blockquote><p>Returns an unsafe pointer to the vector&rsquo;s buffer</p><p>The caller must ensure that the vector outlives the pointer this function returns, or else it will end up pointing to garbage.</p><p>Modifying the vector may cause its buffer to be reallocated, which would also make any pointers to it invalid.</p></div></div></div>

</div><!--Content-->


<div id=Footer><a href="http://www.naturaldocs.org">Generated by Natural Docs</a></div><!--Footer-->


<div id=Menu><div class=MEntry><div class=MFile><a href="bitv-rs.html">bitv</a></div></div><div class=MEntry><div class=MFile><a href="bool-rs.html">bool</a></div></div><div class=MEntry><div class=MFile><a href="box-rs.html">box</a></div></div><div class=MEntry><div class=MFile><a href="c_vec-rs.html">c_vec</a></div></div><div class=MEntry><div class=MFile><a href="char-rs.html">char</a></div></div><div class=MEntry><div class=MFile><a href="comm-rs.html">comm</a></div></div><div class=MEntry><div class=MFile><a href="ctypes-rs.html">ctypes</a></div></div><div class=MEntry><div class=MFile><a href="deque-rs.html">deque</a></div></div><div class=MEntry><div class=MFile><a href="either-rs.html">either</a></div></div><div class=MEntry><div class=MFile><a href="float-rs.html">float</a></div></div><div class=MEntry><div class=MFile><a href="extfmt-rs.html">fmt</a></div></div><div class=MEntry><div class=MFile><a href="four-rs.html">four</a></div></div><div class=MEntry><div class=MFile><a href="fs-rs.html">fs</a></div></div><div class=MEntry><div class=MFile><a href="fun_treemap-rs.html">fun_treemap</a></div></div><div class=MEntry><div class=MFile><a href="generic_os-rs.html">generic_os</a></div></div><div class=MEntry><div class=MFile><a href="getopts-rs.html">getopts</a></div></div><div class=MEntry><div class=MFile><a href="int-rs.html">int</a></div></div><div class=MEntry><div class=MFile><a href="io-rs.html">io</a></div></div><div class=MEntry><div class=MFile><a href="json-rs.html">json.rs</a></div></div><div class=MEntry><div class=MFile><a href="list-rs.html">list</a></div></div><div class=MEntry><div class=MFile><a href="map-rs.html">map</a></div></div><div class=MEntry><div class=MFile><a href="math-rs.html">math</a></div></div><div class=MEntry><div class=MFile><a href="math_f32-rs.html">math_f32</a></div></div><div class=MEntry><div class=MFile><a href="math_f64-rs.html">math_f64</a></div></div><div class=MEntry><div class=MFile><a href="net-rs.html">net</a></div></div><div class=MEntry><div class=MFile><a href="option-rs.html">option</a></div></div><div class=MEntry><div class=MFile><a href="linux_os-rs.html">os</a></div></div><div class=MEntry><div class=MFile><a href="ptr-rs.html">ptr</a></div></div><div class=MEntry><div class=MFile><a href="rand-rs.html">rand</a></div></div><div class=MEntry><div class=MFile><a href="result-rs.html">result</a></div></div><div class=MEntry><div class=MFile><a href="rope-rs.html">rope</a></div></div><div class=MEntry><div class=MFile><a href="run_program-rs.html">run</a></div></div><div class=MEntry><div class=MFile><a href="sha1-rs.html">sha1</a></div></div><div class=MEntry><div class=MFile><a href="smallintmap-rs.html">smallintmap</a></div></div><div class=MEntry><div class=MFile><a href="sort-rs.html">sort</a></div></div><div class=MEntry><div class=MFile><a href="str-rs.html">str</a></div></div><div class=MEntry><div class=MFile><a href="sys-rs.html">sys</a></div></div><div class=MEntry><div class=MFile><a href="task-rs.html">task</a></div></div><div class=MEntry><div class=MFile><a href="tempfile-rs.html">tempfile</a></div></div><div class=MEntry><div class=MFile><a href="term-rs.html">term</a></div></div><div class=MEntry><div class=MFile><a href="time-rs.html">time</a></div></div><div class=MEntry><div class=MFile><a href="treemap-rs.html">treemap</a></div></div><div class=MEntry><div class=MFile><a href="tri-rs.html">tri</a></div></div><div class=MEntry><div class=MFile><a href="u32-rs.html">u32</a></div></div><div class=MEntry><div class=MFile><a href="u64-rs.html">u64</a></div></div><div class=MEntry><div class=MFile><a href="u8-rs.html">u8</a></div></div><div class=MEntry><div class=MFile><a href="uint-rs.html">uint</a></div></div><div class=MEntry><div class=MFile><a href="unsafe-rs.html">unsafe</a></div></div><div class=MEntry><div class=MFile><a href="util-rs.html">util</a></div></div><div class=MEntry><div class=MFile id=MSelected>vec</div></div><div class=MEntry><div class=MGroup><a href="javascript:ToggleMenu('MGroupContent1')">Index</a><div class=MGroupContent id=MGroupContent1><div class=MEntry><div class=MIndex><a href="../index/General.html">Everything</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Classes.html">Classes</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Constants.html">Constants</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Files.html">Files</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Functions.html">Functions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Modules.html">Modules</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Objects.html">Objects</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Predicates.html">Predicates</a></div></div><div class=MEntry><div class=MIndex><a href="../index/SyntaxExtensions.html">Syntax Extensions</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Tags.html">Tags</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Types.html">Types</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variables.html">Variables</a></div></div><div class=MEntry><div class=MIndex><a href="../index/Variants.html">Variants</a></div></div></div></div></div><script type="text/javascript"><!--
var searchPanel = new SearchPanel("searchPanel", "HTML", "../search");
--></script><div id=MSearchPanel class=MSearchPanelInactive><input type=text id=MSearchField value=Search onFocus="searchPanel.OnSearchFieldFocus(true)" onBlur="searchPanel.OnSearchFieldFocus(false)" onKeyUp="searchPanel.OnSearchFieldChange()"><select id=MSearchType onFocus="searchPanel.OnSearchTypeFocus(true)" onBlur="searchPanel.OnSearchTypeFocus(false)" onChange="searchPanel.OnSearchTypeChange()"><option  id=MSearchEverything selected value="General">Everything</option><option value="Classes">Classes</option><option value="Constants">Constants</option><option value="Files">Files</option><option value="Functions">Functions</option><option value="Modules">Modules</option><option value="Objects">Objects</option><option value="Predicates">Predicates</option><option value="SyntaxExtensions">Syntax Extensions</option><option value="Tags">Tags</option><option value="Types">Types</option><option value="Variables">Variables</option><option value="Variants">Variants</option></select></div><script language=JavaScript><!--
HideAllBut([], 2);// --></script></div><!--Menu-->



<!--START_ND_TOOLTIPS-->
<div class=CToolTip id="tt1"><div class=CType><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>type init_op&lt;T&gt; = block(</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote>A function used to initialize the elements of a vector.</div></div><div class=CToolTip id="tt2"><div class=CPredicate><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn is_empty&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Returns true if a vector contains no elements.</div></div><div class=CToolTip id="tt3"><div class=CPredicate><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn is_not_empty&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Returns true if a vector contains some elements.</div></div><div class=CToolTip id="tt4"><div class=CPredicate><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn same_length&lt;T, U&gt;(</td><td class="PType  prettyprint " nowrap>xs:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>ys:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Returns true if two vectors have the same length</div></div><div class=CToolTip id="tt5"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reserve&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Reserves capacity for `n` elements in the given vector.</div></div><div class=CToolTip id="tt6"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>pure fn len&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; uint</td></tr></table></td></tr></table></blockquote>Returns the length of a vector</div></div><div class=CToolTip id="tt7"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_fn&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Creates and initializes an immutable vector.</div></div><div class=CToolTip id="tt8"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_fn_mut&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote>Creates and initializes a mutable vector.</div></div><div class=CToolTip id="tt9"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_elt&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>t:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Creates and initializes an immutable vector.</div></div><div class=CToolTip id="tt10"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init_elt_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>t:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n_elts:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote>Creates and initializes a mutable vector.</div></div><div class=CToolTip id="tt11"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn to_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote>Produces a mutable vector from an immutable vector.</div></div><div class=CToolTip id="tt12"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn from_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Produces an immutable vector from a mutable vector.</div></div><div class=CToolTip id="tt13"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn head&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; T</td></tr></table></td></tr></table></blockquote>Returns the first element of a vector</div></div><div class=CToolTip id="tt14"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn tail&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Returns all but the first element of a vector</div></div><div class=CToolTip id="tt15"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn init&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Returns all but the last elemnt of a vector</div></div><div class=CToolTip id="tt16"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn last&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;T&gt;</td></tr></table></td></tr></table></blockquote>Returns the last element of a vector</div></div><div class=CToolTip id="tt17"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn last_total&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) : is_not_empty(v) -&gt; T</td></tr></table></td></tr></table></blockquote>Returns the last element of a non-empty vector `v`</div></div><div class=CToolTip id="tt18"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn slice&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Returns a copy of the elements from [`start`..`end`) from `v`.</div></div><div class=CToolTip id="tt19"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn slice_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [mutable T]</td></tr></table></td></tr></table></blockquote>Returns a copy of the elements from [`start`..`end`) from `v`.</div></div><div class=CToolTip id="tt20"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn shift&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote>Removes the first element from a vector and return it</div></div><div class=CToolTip id="tt21"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn pop&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote>Remove the last element from a vector and return it</div></div><div class=CToolTip id="tt22"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Expands a vector in place, initializing the new elements to a given value</div></div><div class=CToolTip id="tt23"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_mut&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Expands a vector in place, initializing the new elements to a given value</div></div><div class=CToolTip id="tt24"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_fn&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>n:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>op:&nbsp;</td><td class="PParameter  prettyprint " nowrap>init_op&lt;T&gt;</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Expands a vector in place, initializing the new elements to the result of a function</div></div><div class=CToolTip id="tt25"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn grow_set&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>index:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>initval:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>val:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets the value of a vector element at a given index, growing the vector as needed</div></div><div class=CToolTip id="tt26"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map&lt;T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote>Apply a function to each element of a vector and return the results</div></div><div class=CToolTip id="tt27"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map_mut&lt;copy T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote>Apply a function to each element of a mutable vector and return the results</div></div><div class=CToolTip id="tt28"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn map2&lt;copy T, copy U, V&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>V,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v0:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v1:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [V]</td></tr></table></td></tr></table></blockquote>Apply a function to each pair of elements and return the results</div></div><div class=CToolTip id="tt29"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn filter_map&lt;copy T, copy U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>option::t&lt;U&gt;,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [U]</td></tr></table></td></tr></table></blockquote>Apply a function to each element of a vector and return the results</div></div><div class=CToolTip id="tt30"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn filter&lt;copy T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Construct a new vector from the elements of a vector for which some predicate holds.</div></div><div class=CToolTip id="tt31"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn concat&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const [const T]]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Concatenate a vector of vectors. </div></div><div class=CToolTip id="tt32"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn foldl&lt;copy T, U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>p: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>z:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const U]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; T</td></tr></table></td></tr></table></blockquote>Reduce a vector from left to right</div></div><div class=CToolTip id="tt33"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn foldr&lt;T, copy U&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>p: block(T, U)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>z:&nbsp;</td><td class="PParameter  prettyprint " nowrap>U,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; U</td></tr></table></td></tr></table></blockquote>Reduce a vector from right to left</div></div><div class=CToolTip id="tt34"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn any&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Return true if a predicate matches any elements</div></div><div class=CToolTip id="tt35"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn all&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Return true if a predicate matches all elements</div></div><div class=CToolTip id="tt36"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn member&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; bool</td></tr></table></td></tr></table></blockquote>Return true if a vector contains an element with the given value</div></div><div class=CToolTip id="tt37"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn count&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; uint</td></tr></table></td></tr></table></blockquote>Returns the number of elements that are equal to a given value</div></div><div class=CToolTip id="tt38"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn find&lt;copy T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;T&gt;</td></tr></table></td></tr></table></blockquote>Search for an element that matches a given predicate</div></div><div class=CToolTip id="tt39"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn position&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>x:&nbsp;</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;uint&gt;</td></tr></table></td></tr></table></blockquote>Find the first index containing a matching value</div></div><div class=CToolTip id="tt40"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn position_pred&lt;T&gt;(</td><td class="PTypePrefix  prettyprint " nowrap>f: block(T)&nbsp;</td><td class="PType  prettyprint " nowrap>-&gt;&nbsp;</td><td class="PParameter  prettyprint " nowrap>bool,</td></tr><tr><td></td><td class="PTypePrefix  prettyprint " nowrap></td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; option::t&lt;uint&gt;</td></tr></table></td></tr></table></blockquote>Find the first index for which the value matches some predicate</div></div><div class=CToolTip id="tt41"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn unzip&lt;copy T, copy U&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[(T, U)]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; ([T], [U])</td></tr></table></td></tr></table></blockquote>Convert a vector of pairs into a pair of vectors</div></div><div class=CToolTip id="tt42"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn zip&lt;copy T, copy U&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>u:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[U]</td><td class="PAfterParameters  prettyprint "nowrap>) : same_length(v, u) -&gt; [(T, U)]</td></tr></table></td></tr></table></blockquote>Convert two vectors to a vector of pairs</div></div><div class=CToolTip id="tt43"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn swap&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>a:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>b:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Swaps two elements in a vector</div></div><div class=CToolTip id="tt44"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reverse&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[mutable T]</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Reverse the order of elements in a vector, in place</div></div><div class=CToolTip id="tt45"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn reversed&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Returns a vector with the order of elements reversed</div></div><div class=CToolTip id="tt46"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn enum_chars(</td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>u8,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>u8</td><td class="PAfterParameters  prettyprint "nowrap>) : u8::le(start, end) -&gt; [char]</td></tr></table></td></tr></table></blockquote>Returns a vector containing a range of chars</div></div><div class=CToolTip id="tt47"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn enum_uints(</td><td class="PType  prettyprint " nowrap>start:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>end:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) : uint::le(start, end) -&gt; [uint]</td></tr></table></td></tr></table></blockquote>Returns a vector containing a range of uints</div></div><div class=CToolTip id="tt48"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn iter&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Iterates over a vector</div></div><div class=CToolTip id="tt49"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn iter2&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(uint, T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Iterates over a vector&rsquo;s elements and indexes</div></div><div class=CToolTip id="tt50"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn riter&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Iterates over a vector in reverse</div></div><div class=CToolTip id="tt51"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn riter2&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>f:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block(uint, T)</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Iterates over a vector&rsquo;s elements and indexes in reverse</div></div><div class=CToolTip id="tt52"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>fn permute&lt;copy T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>put:&nbsp;</td><td class="PParameter  prettyprint " nowrap>block([T])</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Iterate over all permutations of vector `v`. </div></div><div class=CToolTip id="tt53"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn to_ptr&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; *T</td></tr></table></td></tr></table></blockquote>FIXME: We don&rsquo;t need this wrapper</div></div><div class=CToolTip id="tt54"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn from_buf&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>ptr:&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap>*</td><td class="PParameter  prettyprint " nowrap>T,</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>elts:&nbsp;</td><td class="PParameterPrefix  prettyprint " nowrap></td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; [T]</td></tr></table></td></tr></table></blockquote>Constructs a vector from an unsafe pointer to a buffer</div></div><div class=CToolTip id="tt55"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn set_len&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>&amp;v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T],</td></tr><tr><td></td><td class="PType  prettyprint " nowrap>new_len:&nbsp;</td><td class="PParameter  prettyprint " nowrap>uint</td><td class="PAfterParameters  prettyprint "nowrap>)</td></tr></table></td></tr></table></blockquote>Sets the length of a vector</div></div><div class=CToolTip id="tt56"><div class=CFunction><blockquote><table border=0 cellspacing=0 cellpadding=0 class="Prototype"><tr><td><table border=0 cellspacing=0 cellpadding=0><tr><td class="PBeforeParameters  prettyprint "nowrap>unsafe fn to_ptr&lt;T&gt;(</td><td class="PType  prettyprint " nowrap>v:&nbsp;</td><td class="PParameter  prettyprint " nowrap>[const T]</td><td class="PAfterParameters  prettyprint "nowrap>) -&gt; *T</td></tr></table></td></tr></table></blockquote>Returns an unsafe pointer to the vector&rsquo;s buffer</div></div><!--END_ND_TOOLTIPS-->




<div id=MSearchResultsWindow><iframe src="" frameborder=0 name=MSearchResults id=MSearchResults></iframe><a href="javascript:searchPanel.CloseResultsWindow()" id=MSearchResultsWindowClose>Close</a></div>


<script language=JavaScript><!--
if (browserType) {if (browserVer) {document.write("</div>"); }document.write("</div>");}// --></script></body></html>