<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Functions</title></head><body>
<p class="head">Section 5 of the Rust language tutorial.<br><a href="control.html">« Section 4</a> | <a href="index.html">Index</a> | <a href="data.html">Section 6 »</a></p><div id="content"><h1>Functions</h1>

<p>Functions (like all other static declarations, such as <code>type</code>) can be
declared both at the top level and inside other functions (or modules,
which we&#39;ll come back to in moment).</p>

<p>The <code>ret</code> keyword immediately returns from a function. It is
optionally followed by an expression to return. In functions that
return <code>()</code>, the returned expression can be left off. A function can
also return a value by having its top level block produce an
expression (by omitting the final semicolon).</p>

<p>Some functions (such as the C function <code>exit</code>) never return normally.
In Rust, these are annotated with return type <code>!</code>:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">dead_end</span>() -&gt; ! { <span class="cm-variable">fail</span>; }</pre>

<p>This helps the compiler avoid spurious error messages. For example,
the following code would be a type error if <code>dead_end</code> would be
expected to return.</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">dir</span> = <span class="cm-keyword">if</span> <span class="cm-variable">can_go_left</span>() { <span class="cm-variable">left</span> }
          <span class="cm-keyword">else</span> <span class="cm-keyword">if</span> <span class="cm-variable">can_go_right</span>() { <span class="cm-variable">right</span> }
          <span class="cm-keyword">else</span> { <span class="cm-variable">dead_end</span>(); };</pre>

<h2>Closures</h2>

<p>Normal Rust functions (declared with <code>fn</code>) do not close over their
environment. A <code>lambda</code> expression can be used to create a closure.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">make_plus_function</span>(<span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-variable-3">lambda</span>(<span class="cm-def">int</span>) -&gt; <span class="cm-keyword">int</span> {
    <span class="cm-keyword">lambda</span>(<span class="cm-def">y</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">x</span> + <span class="cm-variable">y</span> }
}
<span class="cm-keyword">let</span> <span class="cm-def">plus_two</span> = <span class="cm-variable">make_plus_function</span>(<span class="cm-number">2</span>);
<span class="cm-keyword">assert</span> <span class="cm-variable">plus_two</span>(<span class="cm-number">3</span>) == <span class="cm-number">5</span>;</pre>

<p>A <code>lambda</code> function <em>copies</em> its environment (in this case, the
binding for <code>x</code>). It can not mutate the closed-over bindings, and will
not see changes made to these variables after the <code>lambda</code> was
evaluated. <code>lambda</code>s can be put in data structures and passed around
without limitation.</p>

<p>The type of a closure is <code>lambda(args) -&gt; type</code>, as opposed to
<code>fn(args) -&gt; type</code>. The <code>fn</code> type stands for &#39;bare&#39; functions, with no
closure attached. Keep this in mind when writing higher-order
functions.</p>

<p>A different form of closure is the block. Blocks are written like they
are in Ruby: <code>{|x| x + y}</code>, the formal parameters between pipes,
followed by the function body. They are stack-allocated and properly
close over their environment (they see updates to closed over
variables, for example). But blocks can only be used in a limited set
of circumstances. They can be passed to other functions, but not
stored in data structures or returned.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">map_int</span>(<span class="cm-def">f</span>: <span class="cm-keyword">block</span>(<span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span>, <span class="cm-def">vec</span>: [<span class="cm-keyword">int</span>]) -&gt; [<span class="cm-keyword">int</span>] {
    <span class="cm-keyword">let</span> <span class="cm-def">result</span> = [];
    <span class="cm-keyword">for</span> <span class="cm-def">i</span> <span class="cm-keyword">in</span> <span class="cm-variable">vec</span> { <span class="cm-variable">result</span> += [<span class="cm-variable">f</span>(<span class="cm-variable">i</span>)]; }
    <span class="cm-keyword">ret</span> <span class="cm-variable">result</span>;
}
<span class="cm-variable">map_int</span>({|<span class="cm-def">x</span>| <span class="cm-variable">x</span> + <span class="cm-number">1</span> }, [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]);</pre>

<p>The type of blocks is spelled <code>block(args) -&gt; type</code>. Both closures and
bare functions are automatically convert to <code>block</code>s when appropriate.
Most higher-order functions should take their function arguments as
<code>block</code>s.</p>

<p>A block with no arguments is written <code>{|| body(); }</code>—you can not leave
off the pipes.</p>

<h2>Binding</h2>

<p>Partial application is done using the <code>bind</code> keyword in Rust.</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">daynum</span> = <span class="cm-keyword">bind</span> <span class="cm-variable-2">std::vec::</span><span class="cm-variable">position</span>(<span class="cm-variable">_</span>, [<span class="cm-string">&quot;mo&quot;</span>, <span class="cm-string">&quot;tu&quot;</span>, <span class="cm-string">&quot;we&quot;</span>, <span class="cm-string">&quot;do&quot;</span>,
                                         <span class="cm-string">&quot;fr&quot;</span>, <span class="cm-string">&quot;sa&quot;</span>, <span class="cm-string">&quot;su&quot;</span>]);</pre>

<p>Binding a function produces a closure (<code>lambda</code> type) in which some of
the arguments to the bound function have already been provided.
<code>daynum</code> will be a function taking a single string argument, and
returning the day of the week that string corresponds to (if any).</p>

<h2>Iteration</h2>

<p>Functions taking blocks provide a good way to define non-trivial
iteration constructs. For example, this one iterates over a vector
of integers backwards:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">for_rev</span>(<span class="cm-def">v</span>: [<span class="cm-keyword">int</span>], <span class="cm-def">act</span>: <span class="cm-keyword">block</span>(<span class="cm-keyword">int</span>)) {
    <span class="cm-keyword">let</span> <span class="cm-def">i</span> = <span class="cm-variable-2">std::vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">v</span>);
    <span class="cm-keyword">while</span> (<span class="cm-variable">i</span> &gt; <span class="cm-number">0</span><span class="cm-variable">u</span>) {
        <span class="cm-variable">i</span> -= <span class="cm-number">1</span><span class="cm-variable">u</span>;
        <span class="cm-variable">act</span>(<span class="cm-variable">v</span>[<span class="cm-variable">i</span>]);
    }
}</pre>

<p>To run such an iteration, you could do this:</p>

<pre class="cm-s-default"><span class="cm-variable">for_rev</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>], {|<span class="cm-def">n</span>| <span class="cm-keyword">log</span> <span class="cm-variable">n</span>; });</pre>

<p>But Rust allows a more pleasant syntax for this situation, with the
loop block moved out of the parenthesis and the final semicolon
omitted:</p>

<pre class="cm-s-default"><span class="cm-variable">for_rev</span>([<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]) {|<span class="cm-def">n</span>|
    <span class="cm-keyword">log</span> <span class="cm-variable">n</span>;
}</pre></div><p class="head">Section 5 of the Rust language tutorial.<br><a href="control.html">« Section 4</a> | <a href="index.html">Index</a> | <a href="data.html">Section 6 »</a></p><p class='head'>Created September 31, 2011, last modified on October 2, 2011</p></body></html>