<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Modules and crates</title></head><body>
<p class="head">Section 9 of the Rust language tutorial.<br><a href="generic.html">« Section 8</a> | <a href="index.html">Index</a> | <a href="iface.html">Section 10 »</a></p><div id="content"><h1>Modules and crates</h1>

<p>The Rust namespace is divided into modules. Each source file starts
with its own module.</p>

<h2>Local modules</h2>

<p>The <code>mod</code> keyword can be used to open a new, local module. In the
example below, <code>chicken</code> lives in the module <code>farm</code>, so, unless you
explicitly import it, you must refer to it by its long name,
<code>farm::chicken</code>.</p>

<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">farm</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">chicken</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-string">&quot;cluck cluck&quot;</span> }
    <span class="cm-keyword">fn</span> <span class="cm-def">cow</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-string">&quot;mooo&quot;</span> }
}
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-variable-2">std::io::</span><span class="cm-variable">println</span>(<span class="cm-variable-2">farm::</span><span class="cm-variable">chicken</span>());
}</pre>

<p>Modules can be nested to arbitrary depth.</p>

<h2>Crates</h2>

<p>The unit of independent compilation in Rust is the crate. Libraries
tend to be packaged as crates, and your own programs may consist of
one or more crates.</p>

<p>When compiling a single <code>.rs</code> file, the file acts as the whole crate.
You can compile it with the <code>--lib</code> compiler switch to create a shared
library, or without, provided that your file contains a <code>fn main</code>
somewhere, to create an executable.</p>

<p>It is also possible to include multiple files in a crate. For this
purpose, you create a <code>.rc</code> crate file, which references any number of
<code>.rs</code> code files. A crate file could look like this:</p>

<pre class="cm-s-default">#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.5&quot;</span>, <span class="cm-variable">author</span> = <span class="cm-string">&quot;mjh&quot;</span>)];
<span class="cm-keyword">mod</span> <span class="cm-def">cow</span>;
<span class="cm-keyword">mod</span> <span class="cm-def">chicken</span>;
<span class="cm-keyword">mod</span> <span class="cm-def">horse</span>;</pre>

<p>Compiling this file will cause <code>rustc</code> to look for files named
<code>cow.rs</code>, <code>chicken.rs</code>, <code>horse.rs</code> in the same directory as the <code>.rc</code>
file, compile them all together, and, depending on the presence of the
<code>--lib</code> switch, output a shared library or an executable.</p>

<p>The <code>#[link(...)]</code> part provides meta information about the module,
which other crates can use to load the right module. More about that
later.</p>

<p>To have a nested directory structure for your source files, you can
nest mods in your <code>.rc</code> file:</p>

<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">poultry</span> {
    <span class="cm-keyword">mod</span> <span class="cm-def">chicken</span>;
    <span class="cm-keyword">mod</span> <span class="cm-def">turkey</span>;
}</pre>

<p>The compiler will now look for <code>poultry/chicken.rs</code> and
<code>poultry/turkey.rs</code>, and export their content in <code>poultry::chicken</code>
and <code>poultry::turkey</code>. You can also provide a <code>poultry.rs</code> to add
content to the <code>poultry</code> module itself.</p>

<h2>Using other crates</h2>

<p>Having compiled a crate with <code>--lib</code>, you can use it in another crate
with a <code>use</code> directive. We&#39;ve already seen <code>use std</code> in several of the
examples, which loads in the <a href="http://doc.rust-lang.org/doc/std/index/General.html">standard library</a>.</p>

<p><code>use</code> directives can appear in a crate file, or at the top level of a
single-file <code>.rs</code> crate. They will cause the compiler to search its
library search path (which you can extend with <code>-L</code> switch) for a Rust
crate library with the right name.</p>

<p>It is possible to provide more specific information when using an
external crate.</p>

<pre class="cm-s-default"><span class="cm-keyword">use</span> <span class="cm-variable">myfarm</span> (<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.7&quot;</span>);</pre>

<p>When a comma-separated list of name/value pairs is given after <code>use</code>,
these are matched against the attributes provided in the <code>link</code>
attribute of the crate file, and a crate is only used when the two
match. A <code>name</code> value can be given to override the name used to search
for the crate. So the above would import the <code>farm</code> crate under the
local name <code>myfarm</code>.</p>

<p>Our example crate declared this set of <code>link</code> attributes:</p>

<pre class="cm-s-default">#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;farm&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;2.5&quot;</span>, <span class="cm-variable">author</span> = <span class="cm-string">&quot;mjh&quot;</span>)];</pre>

<p>The version does not match the one provided in the <code>use</code> directive, so
unless the compiler can find another crate with the right version
somewhere, it will complain that no matching crate was found.</p>

<h2>The core library</h2>

<p>A set of basic library routines, mostly related to built-in datatypes
and the task system, are always implicitly linked and included in any
Rust program, unless the <code>--no-core</code> compiler switch is given.</p>

<p>This library is document <a href="http://doc.rust-lang.org/doc/core/index/General.html">here</a>.</p>

<h2>A minimal example</h2>

<p>Now for something that you can actually compile yourself. We have
these two files:</p>

<pre class="cm-s-default"><span class="cm-comment">// mylib.rs</span>
#[<span class="cm-variable">link</span>(<span class="cm-variable">name</span> = <span class="cm-string">&quot;mylib&quot;</span>, <span class="cm-variable">vers</span> = <span class="cm-string">&quot;1.0&quot;</span>)];
<span class="cm-keyword">fn</span> <span class="cm-def">world</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-string">&quot;world&quot;</span> }
<span class="cm-comment">// main.rs</span>
<span class="cm-keyword">use</span> <span class="cm-variable">mylib</span>;
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() { <span class="cm-variable-2">std::io::</span><span class="cm-variable">println</span>(<span class="cm-string">&quot;hello &quot;</span> + <span class="cm-variable-2">mylib::</span><span class="cm-variable">world</span>()); }</pre>

<p>Now compile and run like this (adjust to your platform if necessary):</p>

<pre>&gt; rustc --lib mylib.rs
&gt; rustc main.rs -L .
&gt; ./main
&quot;hello world&quot;</pre>

<h2>Importing</h2>

<p>When using identifiers from other modules, it can get tiresome to
qualify them with the full module path every time (especially when
that path is several modules deep). Rust allows you to import
identifiers at the top of a file, module, or block.</p>

<pre class="cm-s-default"><span class="cm-keyword">use</span> <span class="cm-variable">std</span>;
<span class="cm-keyword">import</span> <span class="cm-variable-2">std::io::</span><span class="cm-variable">println</span>;
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-variable">println</span>(<span class="cm-string">&quot;that was easy&quot;</span>);
}</pre>

<p>It is also possible to import just the name of a module (<code>import
std::io;</code>, then use <code>io::println</code>), to import all identifiers exported
by a given module (<code>import std::io::*</code>), or to import a specific set
of identifiers (<code>import math::{min, max, pi}</code>).</p>

<p>You can rename an identifier when importing using the <code>=</code> operator:</p>

<pre class="cm-s-default"><span class="cm-keyword">import</span> <span class="cm-variable">prnt</span> = <span class="cm-variable-2">std::io::</span><span class="cm-variable">println</span>;</pre>

<h2>Exporting</h2>

<p>By default, a module exports everything that it defines. This can be
restricted with <code>export</code> directives at the top of the module or file.</p>

<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">enc</span> {
    <span class="cm-keyword">export</span> <span class="cm-variable">encrypt</span>, <span class="cm-variable">decrypt</span>;
    <span class="cm-keyword">const</span> <span class="cm-def">super_secret_number</span>: <span class="cm-keyword">int</span> = <span class="cm-number">10</span>;
    <span class="cm-keyword">fn</span> <span class="cm-def">encrypt</span>(<span class="cm-def">n</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">n</span> + <span class="cm-variable">super_secret_number</span> }
    <span class="cm-keyword">fn</span> <span class="cm-def">decrypt</span>(<span class="cm-def">n</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">n</span> - <span class="cm-variable">super_secret_number</span> }
}</pre>

<p>This defines a rock-solid encryption algorithm. Code outside of the
module can refer to the <code>enc::encrypt</code> and <code>enc::decrypt</code> identifiers
just fine, but it does not have access to <code>enc::super_secret_number</code>.</p>

<h2>Namespaces</h2>

<p>Rust uses three different namespaces. One for modules, one for types,
and one for values. This means that this code is valid:</p>

<pre class="cm-s-default"><span class="cm-keyword">mod</span> <span class="cm-def">buffalo</span> {
    <span class="cm-keyword">type</span> <span class="cm-def">buffalo</span> = <span class="cm-keyword">int</span>;
    <span class="cm-keyword">fn</span> <span class="cm-def">buffalo</span>(<span class="cm-def">buffalo</span>: <span class="cm-variable-3">buffalo</span>) -&gt; <span class="cm-variable-3">buffalo</span> { <span class="cm-variable">buffalo</span> }
}
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">buffalo</span>: <span class="cm-variable-2">buffalo::</span><span class="cm-variable-3">buffalo</span> = <span class="cm-number">1</span>;
    <span class="cm-variable-2">buffalo::</span><span class="cm-variable">buffalo</span>(<span class="cm-variable-2">buffalo::</span><span class="cm-variable">buffalo</span>(<span class="cm-variable">buffalo</span>));
}</pre>

<p>You don&#39;t want to write things like that, but it <em>is</em> very practical
to not have to worry about name clashes between types, values, and
modules. This allows us to have a module <code>core::str</code>, for example, even
though <code>str</code> is a built-in type name.</p>

<h2>Resolution</h2>

<p>The resolution process in Rust simply goes up the chain of contexts,
looking for the name in each context. Nested functions and modules
create new contexts inside their parent function or module. A file
that&#39;s part of a bigger crate will have that crate&#39;s context as parent
context.</p>

<p>Identifiers can shadow each others. In this program, <code>x</code> is of type
<code>int</code>:</p>

<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">t</span> = <span class="cm-keyword">str</span>;
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-keyword">type</span> <span class="cm-def">t</span> = <span class="cm-keyword">int</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">x</span>: <span class="cm-variable-3">t</span>;
}</pre>

<p>An <code>import</code> directive will only import into the namespaces for which
identifiers are actually found. Consider this example:</p>

<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">bar</span> = <span class="cm-keyword">uint</span>;
<span class="cm-keyword">mod</span> <span class="cm-def">foo</span> { <span class="cm-keyword">fn</span> <span class="cm-def">bar</span>() {} }
<span class="cm-keyword">mod</span> <span class="cm-def">baz</span> {
    <span class="cm-keyword">import</span> <span class="cm-variable-2">foo::</span><span class="cm-variable">bar</span>;
    <span class="cm-keyword">const</span> <span class="cm-def">x</span>: <span class="cm-variable-3">bar</span> = <span class="cm-number">20</span><span class="cm-variable">u</span>;
}</pre>

<p>When resolving the type name <code>bar</code> in the <code>const</code> definition, the
resolver will first look at the module context for <code>baz</code>. This has an
import named <code>bar</code>, but that&#39;s a function, not a type, So it continues
to the top level and finds a type named <code>bar</code> defined there.</p>

<p>Normally, multiple definitions of the same identifier in a scope are
disallowed. Local variables defined with <code>let</code> are an exception to
this—multiple <code>let</code> directives can redefine the same variable in a
single scope. When resolving the name of such a variable, the most
recent definition is used.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-number">10</span>;
    <span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-variable">x</span> + <span class="cm-number">10</span>;
    <span class="cm-keyword">assert</span> <span class="cm-variable">x</span> == <span class="cm-number">20</span>;
}</pre>

<p>This makes it possible to rebind a variable without actually mutating
it, which is mostly useful for destructuring (which can rebind, but
not assign).</p></div><p class="head">Section 9 of the Rust language tutorial.<br><a href="generic.html">« Section 8</a> | <a href="index.html">Index</a> | <a href="iface.html">Section 10 »</a></p><p class='head'>Created September 31, 2011, last modified on  12, 2012</p></body></html>