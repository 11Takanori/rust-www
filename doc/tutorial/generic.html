<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Generics</title></head><body>
<p class="head">Section 8 of the Rust language tutorial.<br><a href="args.html">« Section 7</a> | <a href="index.html">Index</a> | <a href="mod.html">Section 9 »</a></p><div id="content"><h1>Generics</h1>

<h2>Generic functions</h2>

<p>Throughout this tutorial, I&#39;ve been defining functions like <code>map</code> and
<code>for_rev</code> to take vectors of integers. It is 2011, and we no longer
expect to be defining such functions again and again for every type
they apply to. Thus, Rust allows functions and datatypes to have type
parameters.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">for_rev</span>&lt;<span class="cm-variable-3">T</span>&gt;(<span class="cm-def">v</span>: [<span class="cm-variable-3">T</span>], <span class="cm-def">act</span>: <span class="cm-keyword">block</span>(<span class="cm-variable-3">T</span>)) {
    <span class="cm-keyword">let</span> <span class="cm-def">i</span> = <span class="cm-variable-2">std::vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">v</span>);
    <span class="cm-keyword">while</span> <span class="cm-variable">i</span> &gt; <span class="cm-number">0</span><span class="cm-variable">u</span> {
        <span class="cm-variable">i</span> -= <span class="cm-number">1</span><span class="cm-variable">u</span>;
        <span class="cm-variable">act</span>(<span class="cm-variable">v</span>[<span class="cm-variable">i</span>]);
    }
}</pre>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">map</span>&lt;<span class="cm-variable-3">T</span>, <span class="cm-variable-3">U</span>&gt;(<span class="cm-def">f</span>: <span class="cm-keyword">block</span>(<span class="cm-variable-3">T</span>) -&gt; <span class="cm-variable-3">U</span>, <span class="cm-def">v</span>: [<span class="cm-variable-3">T</span>]) -&gt; [<span class="cm-variable-3">U</span>] {
    <span class="cm-keyword">let</span> <span class="cm-def">acc</span> = [];
    <span class="cm-keyword">for</span> <span class="cm-def">elt</span> <span class="cm-keyword">in</span> <span class="cm-variable">v</span> { <span class="cm-variable">acc</span> += [<span class="cm-variable">f</span>(<span class="cm-variable">elt</span>)]; }
    <span class="cm-keyword">ret</span> <span class="cm-variable">acc</span>;
}</pre>

<p>When defined in this way, these functions can be applied to any type
of vector, as long as the type of the block&#39;s argument and the type of
the vector&#39;s content agree with each other.</p>

<p>Inside a parameterized (generic) function, the names of the type
parameters (capitalized by convention) stand for opaque types. You
can&#39;t look inside them, but you can pass them around.</p>

<h2>Generic datatypes</h2>

<p>Generic <code>type</code> and <code>tag</code> declarations follow the same pattern:</p>

<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">circular_buf</span>&lt;<span class="cm-variable-3">T</span>&gt; = {<span class="cm-variable">start</span>: <span class="cm-keyword">uint</span>,
                        <span class="cm-variable">end</span>: <span class="cm-keyword">uint</span>,
                        <span class="cm-variable">buf</span>: [<span class="cm-variable-3">mutable</span> <span class="cm-variable">T</span>]};</pre>

<pre class="cm-s-default"><span class="cm-keyword">tag</span> <span class="cm-def">option</span>&lt;<span class="cm-variable-3">T</span>&gt; { <span class="cm-def">some</span>(<span class="cm-variable-3">T</span>); <span class="cm-def">none</span>; }</pre>

<p>You can then declare a function to take a <code>circular_buf&lt;u8&gt;</code> or return
an <code>option&lt;str&gt;</code>, or even an <code>option&lt;T&gt;</code> if the function itself is
generic.</p>

<p>The <code>option</code> type given above exists in the standard library as
<code>std::option::t</code>, and is the way Rust programs express the thing that
in C would be a nullable pointer. The nice part is that you have to
explicitly unpack an <code>option</code> type, so accidental null pointer
dereferences become impossible.</p>

<h2>Type-inference and generics</h2>

<p>Rust&#39;s type inferrer works very well with generics, but there are
programs that just can&#39;t be typed.</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">n</span> = <span class="cm-variable">none</span>;</pre>

<p>If you never do anything else with none, the compiler will not be able
to assign a type to it. (The same goes for <code>[]</code>, in fact.) If you
really want to have such a statement, you&#39;ll have to write it like
this:</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">n</span> = <span class="cm-variable">none</span>::&lt;<span class="cm-variable-3">int</span>&gt;;</pre>

<p>Note that, in a value expression, <code>&lt;</code> already has a meaning as a
comparison operator, so you&#39;ll have to write <code>::&lt;T&gt;</code> to explicitly
give a type to a name that denotes a generic value. Fortunately, this
is rarely necessary.</p>

<h2>Polymorphic built-ins</h2>

<p>There are two built-in operations that, perhaps surprisingly, act on
values of any type. It was already mentioned earlier that <code>log</code> can
take any type of value and output it as a string.</p>

<p>More interesting is that Rust also defines an ordering for all
datatypes, and allows you to meaningfully apply comparison operators
(<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>==</code>, <code>!=</code>) to them. For structural types, the
comparison happens left to right, so <code>&quot;abc&quot; &lt; &quot;bac&quot;</code> (but note that
<code>&quot;bac&quot; &lt; &quot;ác&quot;</code>, because the ordering acts on UTF-8 sequences without
any sophistication).</p>

<h2>Generic functions and argument-passing</h2>

<p>If you try this program:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">plus1</span>(<span class="cm-def">x</span>: <span class="cm-keyword">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">x</span> + <span class="cm-number">1</span> }
<span class="cm-variable">map</span>(<span class="cm-variable">plus1</span>, [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]);</pre>

<p>You will get an error message about argument passing styles
disagreeing. The reason is that generic types are always passed by
pointer, so <code>map</code> expects a function that takes its argument by
pointer. The <code>plus1</code> you defined, however, uses the default, efficient
way to pass integers, which is by value. To get around this issue, you
have to explicitly mark the arguments to a function that you want to
pass to a generic higher-order function as being passed by pointer:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">plus1</span>(&amp;&amp;<span class="cm-variable">x</span>: <span class="cm-variable">int</span>) -&gt; <span class="cm-keyword">int</span> { <span class="cm-variable">x</span> + <span class="cm-number">1</span> }
<span class="cm-variable">map</span>(<span class="cm-variable">plus1</span>, [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]);</pre>

<p>NOTE: This is inconvenient, and we are hoping to get rid of this
restriction in the future.</p>

<p>FIXME discuss kinds, when they have settled</p></div><p class="head">Section 8 of the Rust language tutorial.<br><a href="args.html">« Section 7</a> | <a href="index.html">Index</a> | <a href="mod.html">Section 9 »</a></p><p class='head'>Created September 31, 2011, last modified on October 1, 2011</p></body></html>