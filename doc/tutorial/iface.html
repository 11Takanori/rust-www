<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Interfaces</title></head><body>
<p class="head">Section 10 of the Rust language tutorial.<br><a href="mod.html">« Section 9</a> | <a href="index.html">Index</a> | <a href="ffi.html">Section 11 »</a></p><div id="content"><h1>Interfaces</h1>

<p>Interfaces are Rust&#39;s take on value polymorphism—the thing that
object-oriented languages tend to solve with methods and inheritance.
For example, writing a function that can operate on multiple types of
collections.</p>

<p>NOTE: This feature is very new, and will need a few extensions to be
applicable to more advanced use cases.</p>

<h2>Declaration</h2>

<p>An interface consists of a set of methods. A method is a function that
can be applied to a <code>self</code> value and a number of arguments, using the
dot notation: <code>self.foo(arg1, arg2)</code>.</p>

<p>For example, we could declare the interface <code>to_str</code> for things that
can be converted to a string, with a single method of the same name:</p>

<pre class="cm-s-default"><span class="cm-keyword">iface</span> <span class="cm-variable">to_str</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">to_str</span>() -&gt; <span class="cm-keyword">str</span>;
}</pre>

<h2>Implementation</h2>

<p>To actually implement an interface for a given type, the <code>impl</code> form
is used. This defines implementations of <code>to_str</code> for the <code>int</code> and
<code>str</code> types.</p>

<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-variable">of</span> <span class="cm-variable">to_str</span> <span class="cm-keyword">for</span> <span class="cm-def">int</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">to_str</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-variable-2">int::</span><span class="cm-variable">to_str</span>(<span class="cm-variable">self</span>, <span class="cm-number">10</span><span class="cm-variable">u</span>) }
}
<span class="cm-keyword">impl</span> <span class="cm-variable">of</span> <span class="cm-variable">to_str</span> <span class="cm-keyword">for</span> <span class="cm-def">str</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">to_str</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-variable">self</span> }
}</pre>

<p>Given these, we may call <code>1.to_str()</code> to get <code>&quot;1&quot;</code>, or
<code>&quot;foo&quot;.to_str()</code> to get <code>&quot;foo&quot;</code> again. This is basically a form of
static overloading—when the Rust compiler sees the <code>to_str</code> method
call, it looks for an implementation that matches the type with a
method that matches the name, and simply calls that.</p>

<h2>Scoping</h2>

<p>Implementations are not globally visible. Resolving a method to an
implementation requires that implementation to be in scope. You can
import and export implementations using the name of the interface they
implement (multiple implementations with the same name can be in scope
without problems). Or you can give them an explicit name if you
prefer, using this syntax:</p>

<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-variable">nil_to_str</span> <span class="cm-variable">of</span> <span class="cm-variable">to_str</span> <span class="cm-keyword">for</span> () {
    <span class="cm-keyword">fn</span> <span class="cm-def">to_str</span>() -&gt; <span class="cm-keyword">str</span> { <span class="cm-string">&quot;()&quot;</span> }
}</pre>

<h2>Bounded type parameters</h2>

<p>The useful thing about value polymorphism is that it does not have to
be static. If object-oriented languages only let you call a method on
an object when they knew exactly which sub-type it had, that would not
get you very far. To be able to call methods on types that aren&#39;t
known at compile time, it is possible to specify &#39;bounds&#39; for type
parameters.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">comma_sep</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">to_str</span>&gt;(<span class="cm-def">elts</span>: [<span class="cm-variable-3">T</span>]) -&gt; <span class="cm-keyword">str</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">result</span> = <span class="cm-string">&quot;&quot;</span>, <span class="cm-def">first</span> = <span class="cm-atom">true</span>;
    <span class="cm-keyword">for</span> <span class="cm-def">elt</span> <span class="cm-keyword">in</span> <span class="cm-variable">elts</span> {
        <span class="cm-keyword">if</span> <span class="cm-variable">first</span> { <span class="cm-variable">first</span> = <span class="cm-atom">false</span>; }
        <span class="cm-keyword">else</span> { <span class="cm-variable">result</span> += <span class="cm-string">&quot;, &quot;</span>; }
        <span class="cm-variable">result</span> += <span class="cm-variable">elt</span>.<span class="cm-variable">to_str</span>();
    }
    <span class="cm-keyword">ret</span> <span class="cm-variable">result</span>;
}</pre>

<p>The syntax for this is similar to the syntax for specifying that a
parameter type has to be copyable (which is, in principle, another
kind of bound). By declaring <code>T</code> as conforming to the <code>to_str</code>
interface, it becomes possible to call methods from that interface on
values of that type inside the function. It will also cause a
compile-time error when anyone tries to call <code>comma_sep</code> on an array
whose element type does not have a <code>to_str</code> implementation in scope.</p>

<h2>Polymorphic interfaces</h2>

<p>Interfaces may contain type parameters. This defines an interface for
generalized sequence types:</p>

<pre class="cm-s-default"><span class="cm-keyword">iface</span> <span class="cm-variable">seq</span>&lt;<span class="cm-variable">T</span>&gt; {
    <span class="cm-keyword">fn</span> <span class="cm-def">len</span>() -&gt; <span class="cm-keyword">uint</span>;
    <span class="cm-keyword">fn</span> <span class="cm-def">iter</span>(<span class="cm-def">block</span>(<span class="cm-variable">T</span>));
}
<span class="cm-keyword">impl</span> &lt;<span class="cm-variable-3">T</span>&gt; <span class="cm-def">of</span> <span class="cm-def">seq</span>&lt;<span class="cm-variable-3">T</span>&gt; <span class="cm-keyword">for</span> [<span class="cm-def">T</span>] {
    <span class="cm-keyword">fn</span> <span class="cm-def">len</span>() -&gt; <span class="cm-keyword">uint</span> { <span class="cm-variable-2">vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">self</span>) }
    <span class="cm-keyword">fn</span> <span class="cm-def">iter</span>(<span class="cm-def">b</span>: <span class="cm-keyword">block</span>(<span class="cm-variable-3">T</span>)) {
        <span class="cm-keyword">for</span> <span class="cm-def">elt</span> <span class="cm-keyword">in</span> <span class="cm-variable">self</span> { <span class="cm-variable">b</span>(<span class="cm-variable">elt</span>); }
    }
}</pre>

<p>Note that the implementation has to explicitly declare the its
parameter <code>T</code> before using it to specify its interface type. This is
needed because it could also, for example, specify an implementation
of <code>seq&lt;int&gt;</code>—the <code>of</code> clause <em>refers</em> to a type, rather than defining
one.</p>

<h2>Casting to an interface type</h2>

<p>The above allows us to define functions that polymorphically act on
values of <em>an</em> unknown type that conforms to a given interface.
However, consider this function:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">draw_all</span>&lt;<span class="cm-variable-3">T</span>: <span class="cm-variable-3">drawable</span>&gt;(<span class="cm-def">shapes</span>: [<span class="cm-variable-3">T</span>]) {
    <span class="cm-keyword">for</span> <span class="cm-def">shape</span> <span class="cm-keyword">in</span> <span class="cm-variable">shapes</span> { <span class="cm-variable">shape</span>.<span class="cm-variable">draw</span>(); }
}</pre>

<p>You can call that on an array of circles, or an array of squares
(assuming those have suitable <code>drawable</code> interfaces defined), but not
on an array containing both circles and squares.</p>

<p>When this is needed, an interface name can be used as a type, causing
the function to be written simply like this:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">draw_all</span>(<span class="cm-def">shapes</span>: [<span class="cm-variable-3">drawable</span>]) {
    <span class="cm-keyword">for</span> <span class="cm-def">shape</span> <span class="cm-keyword">in</span> <span class="cm-variable">shapes</span> { <span class="cm-variable">shape</span>.<span class="cm-variable">draw</span>(); }
}</pre>

<p>There is no type parameter anymore (since there isn&#39;t a single type
that we&#39;re calling the function on). Instead, the <code>drawable</code> type is
used to refer to a type that is a reference-counted box containing a
value for which a <code>drawable</code> implementation exists, combined with
information on where to find the methods for this implementation. This
is very similar to the &#39;vtables&#39; used in most object-oriented
languages.</p>

<p>To construct such a value, you use the <code>as</code> operator to cast a value
to an interface type:</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">c</span>: <span class="cm-variable-3">circle</span> = <span class="cm-variable">new_circle</span>();
<span class="cm-keyword">let</span> <span class="cm-def">r</span>: <span class="cm-variable-3">rectangle</span> = <span class="cm-variable">new_rectangle</span>();
<span class="cm-variable">draw_all</span>([<span class="cm-variable">c</span> <span class="cm-keyword">as</span> <span class="cm-variable">drawable</span>, <span class="cm-variable">r</span> <span class="cm-keyword">as</span> <span class="cm-variable">drawable</span>]);</pre>

<p>This will store the value into a box, along with information about the
implementation (which is looked up in the scope of the cast). The
<code>drawable</code> type simply refers to such boxes, and calling methods on it
always works, no matter what implementations are in scope.</p>

<p>Note that the allocation of a box is somewhat more expensive than
simply using a type parameter and passing in the value as-is, and much
more expensive than statically resolved method calls.</p>

<h2>Interface-less implementations</h2>

<p>If you only intend to use an implementation for static overloading,
and there is no interface available that it conforms to, you are free
to leave off the <code>of</code> clause.</p>

<pre class="cm-s-default"><span class="cm-keyword">impl</span> <span class="cm-variable">int_util</span> <span class="cm-keyword">for</span> <span class="cm-def">int</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">times</span>(<span class="cm-def">b</span>: <span class="cm-keyword">block</span>(<span class="cm-keyword">int</span>)) {
        <span class="cm-keyword">let</span> <span class="cm-def">i</span> = <span class="cm-number">0</span>;
        <span class="cm-keyword">while</span> <span class="cm-variable">i</span> &lt; <span class="cm-variable">self</span> { <span class="cm-variable">b</span>(<span class="cm-variable">i</span>); <span class="cm-variable">i</span> += <span class="cm-number">1</span>; }
    }
    <span class="cm-keyword">fn</span> <span class="cm-def">dollars</span>() -&gt; <span class="cm-variable-3">currency</span> {
        <span class="cm-variable">mk_currency</span>(<span class="cm-variable">self</span>, <span class="cm-string">&quot;USD&quot;</span>)
    }
}</pre>

<p>This allows cutesy things like <code>send_payment(10.dollars())</code>. And the
nice thing is that it&#39;s fully scoped, so the uneasy feeling that
anybody with experience in object-oriented languages (with the
possible exception of Rubyists) gets at the sight of such things is
not justified. It&#39;s harmless!</p></div><p class="head">Section 10 of the Rust language tutorial.<br><a href="mod.html">« Section 9</a> | <a href="index.html">Index</a> | <a href="ffi.html">Section 11 »</a></p><p class='head'>Created  12, 2012</p></body></html>