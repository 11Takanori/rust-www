<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Argument passing</title></head><body>
<p class="head">Section 7 of the Rust language tutorial.<br><a href="data.html">« Section 6</a> | <a href="index.html">Index</a> | <a href="generic.html">Section 8 »</a></p><div id="content"><h1>Argument passing</h1>

<p>Rust datatypes are not trivial to copy (the way, for example,
JavaScript values can be copied by simply taking one or two machine
words and plunking them somewhere else). Shared boxes require
reference count updates, big records, tags, or unique pointers require
an arbitrary amount of data to be copied (plus updating the reference
counts of shared boxes hanging off them).</p>

<p>For this reason, the default calling convention for Rust functions
leaves ownership of the arguments with the caller. The caller
guarantees that the arguments will outlive the call, the callee merely
gets access to them.</p>

<h2>Safe references</h2>

<p>There is one catch with this approach: sometimes the compiler can
<em>not</em> statically guarantee that the argument value at the caller side
will survive to the end of the call. Another argument might indirectly
refer to it and be used to overwrite it, or a closure might assign a
new value to it.</p>

<p>Fortunately, Rust tasks are single-threaded worlds, which share no
data with other tasks, and that most data is immutable. This allows
most argument-passing situations to be proved safe without further
difficulty.</p>

<p>Take the following program:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">main</span>() {
    <span class="cm-keyword">let</span> <span class="cm-def">x</span> = <span class="cm-variable">get_really_big_record</span>();
    <span class="cm-variable">myfunc</span>(<span class="cm-variable">x</span>);
}</pre>

<p>Here we know for sure that no one else has access to the <code>x</code> variable
in <code>main</code>, so we&#39;re good. But the call could also look like this:</p>

<pre class="cm-s-default"><span class="cm-variable">myfunc</span>(<span class="cm-variable">x</span>, {|| <span class="cm-variable">x</span> = <span class="cm-variable">get_another_record</span>(); });</pre>

<p>Now, if <code>myfunc</code> first calls its second argument and then accesses its
first argument, it will see a different value from the one that was
passed to it.</p>

<p>In such a case, the compiler will insert an implicit copy of <code>x</code>,
<em>except</em> if <code>x</code> contains something mutable, in which case a copy would
result in code that behaves differently. If copying <code>x</code> might be
expensive (for example, if it holds a vector), the compiler will emit
a warning.</p>

<p>There are even more tricky cases, in which the Rust compiler is forced
to pessimistically assume a value will get mutated, even though it is
not sure.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">for_each</span>(<span class="cm-def">v</span>: [<span class="cm-variable-3">mutable</span> @<span class="cm-keyword">int</span>], <span class="cm-def">iter</span>: <span class="cm-keyword">block</span>(@<span class="cm-keyword">int</span>)) {
   <span class="cm-keyword">for</span> <span class="cm-def">elt</span> <span class="cm-keyword">in</span> <span class="cm-variable">v</span> { <span class="cm-variable">iter</span>(<span class="cm-variable">elt</span>); }
}</pre>

<p>For all this function knows, calling <code>iter</code> (which is a closure that
might have access to the vector that&#39;s passed as <code>v</code>) could cause the
elements in the vector to be mutated, with the effect that it can not
guarantee that the boxes will live for the duration of the call. So it
has to copy them. In this case, this will happen implicitly (bumping a
reference count is considered cheap enough to not warn about it).</p>

<h2>The copy operator</h2>

<p>If the <code>for_each</code> function given above were to take a vector of
<code>{mutable a: int}</code> instead of <code>@int</code>, it would not be able to
implicitly copy, since if the <code>iter</code> function changes a copy of a
mutable record, the changes won&#39;t be visible in the record itself. If
we <em>do</em> want to allow copies there, we have to explicitly allow it
with the <code>copy</code> operator:</p>

<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">mutrec</span> = {<span class="cm-keyword">mutable</span> <span class="cm-variable">x</span>: <span class="cm-keyword">int</span>};
<span class="cm-keyword">fn</span> <span class="cm-def">for_each</span>(<span class="cm-def">v</span>: [<span class="cm-variable-3">mutable</span> <span class="cm-variable">mutrec</span>], <span class="cm-def">iter</span>: <span class="cm-keyword">block</span>(<span class="cm-variable-3">mutrec</span>)) {
   <span class="cm-keyword">for</span> <span class="cm-def">elt</span> <span class="cm-keyword">in</span> <span class="cm-variable">v</span> { <span class="cm-variable">iter</span>(<span class="cm-keyword">copy</span> <span class="cm-variable">elt</span>); }
}</pre>

<p>Adding a <code>copy</code> operator is also the way to muffle warnings about
implicit copies.</p>

<h2>Other uses of safe references</h2>

<p>Safe references are not only used for argument passing. When you
destructure on a value in an <code>alt</code> expression, or loop over a vector
with <code>for</code>, variables bound to the inside of the given data structure
will use safe references, not copies. This means such references are
very cheap, but you&#39;ll occasionally have to copy them to ensure
safety.</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">my_rec</span> = {<span class="cm-variable">a</span>: <span class="cm-number">4</span>, <span class="cm-variable">b</span>: [<span class="cm-number">1</span>, <span class="cm-number">2</span>, <span class="cm-number">3</span>]};
<span class="cm-keyword">alt</span> <span class="cm-variable">my_rec</span> {
  {<span class="cm-def">a</span>, <span class="cm-def">b</span>} {
    <span class="cm-keyword">log</span>(<span class="cm-variable">info</span>, <span class="cm-variable">b</span>); <span class="cm-comment">// This is okay</span>
    <span class="cm-variable">my_rec</span> = {<span class="cm-variable">a</span>: <span class="cm-variable">a</span> + <span class="cm-number">1</span>, <span class="cm-variable">b</span>: <span class="cm-variable">b</span> + [<span class="cm-variable">a</span>]};
    <span class="cm-keyword">log</span>(<span class="cm-variable">info</span>, <span class="cm-variable">b</span>); <span class="cm-comment">// Here reference b has become invalid</span>
  }
}</pre>

<h2>Argument passing styles</h2>

<p>The fact that arguments are conceptually passed by safe reference does
not mean all arguments are passed by pointer. Composite types like
records and tags <em>are</em> passed by pointer, but single-word values, like
integers and pointers, are simply passed by value. Most of the time,
the programmer does not have to worry about this, as the compiler will
simply pick the most efficient passing style. There is one exception,
which will be described in the section on <a href="generic.html">generics</a>.</p>

<p>To explicitly set the passing-style for a parameter, you prefix the
argument name with a sigil. There are two special passing styles that
are often useful. The first is by-mutable-pointer, written with a
single <code>&amp;</code>:</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">vec_push</span>(&amp;<span class="cm-variable">v</span>: [<span class="cm-variable">int</span>], <span class="cm-def">elt</span>: <span class="cm-keyword">int</span>) {
    <span class="cm-variable">v</span> += [<span class="cm-variable">elt</span>];
}</pre>

<p>This allows the function to mutate the value of the argument, <em>in the
caller&#39;s context</em>. Clearly, you are only allowed to pass things that
can actually be mutated to such a function.</p>

<p>Then there is the by-copy style, written <code>+</code>. This indicates that the
function wants to take ownership of the argument value. If the caller
does not use the argument after the call, it will be &#39;given&#39; to the
callee. Otherwise a copy will be made. This mode is mostly used for
functions that construct data structures. The argument will end up
being owned by the data structure, so if that can be done without a
copy, that&#39;s a win.</p>

<pre class="cm-s-default"><span class="cm-keyword">type</span> <span class="cm-def">person</span> = {<span class="cm-variable">name</span>: <span class="cm-keyword">str</span>, <span class="cm-variable">address</span>: <span class="cm-keyword">str</span>};
<span class="cm-keyword">fn</span> <span class="cm-def">make_person</span>(+<span class="cm-variable">name</span>: <span class="cm-variable">str</span>, +<span class="cm-variable">address</span>: <span class="cm-variable">str</span>) -&gt; <span class="cm-variable-3">person</span> {
    <span class="cm-keyword">ret</span> {<span class="cm-variable">name</span>: <span class="cm-variable">name</span>, <span class="cm-variable">address</span>: <span class="cm-variable">address</span>};
}</pre></div><p class="head">Section 7 of the Rust language tutorial.<br><a href="data.html">« Section 6</a> | <a href="index.html">Index</a> | <a href="generic.html">Section 8 »</a></p><p class='head'>Created September 31, 2011, last modified on  12, 2012</p></body></html>