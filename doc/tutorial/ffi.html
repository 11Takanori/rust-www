<html><head><link rel='stylesheet' href='style.css' type='text/css'><link rel='stylesheet' href='default.css' type='text/css'><meta http-equiv='Content-Type' content='text/html; charset=utf-8'><title>Interacting with foreign code</title></head><body>
<p class="head">Section 11 of the Rust language tutorial.<br><a href="iface.html">« Section 10</a> | <a href="index.html">Index</a> | <a href="task.html">Section 12 »</a></p><div id="content"><h1>Interacting with foreign code</h1>

<p>One of Rust&#39;s aims, as a system programming language, is to
interoperate well with C code.</p>

<p>We&#39;ll start with an example. It&#39;s a bit bigger than usual, and
contains a number of new concepts. We&#39;ll go over it one piece at a
time.</p>

<p>This is a program that uses OpenSSL&#39;s <code>SHA1</code> function to compute the
hash of its first command-line argument, which it then converts to a
hexadecimal string and prints to standard output. If you have the
OpenSSL libraries installed, it should &#39;just work&#39;.</p>

<pre class="cm-s-default"><span class="cm-keyword">use</span> <span class="cm-variable">std</span>;
<span class="cm-keyword">native</span> <span class="cm-keyword">mod</span> <span class="cm-def">crypto</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">SHA1</span>(<span class="cm-def">src</span>: *<span class="cm-keyword">u8</span>, <span class="cm-def">sz</span>: <span class="cm-keyword">uint</span>, <span class="cm-def">out</span>: *<span class="cm-keyword">u8</span>) -&gt; *<span class="cm-keyword">u8</span>;
}
<span class="cm-keyword">fn</span> <span class="cm-def">as_hex</span>(<span class="cm-def">data</span>: [<span class="cm-keyword">u8</span>]) -&gt; <span class="cm-keyword">str</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">acc</span> = <span class="cm-string">&quot;&quot;</span>;
    <span class="cm-keyword">for</span> <span class="cm-def">byte</span> <span class="cm-keyword">in</span> <span class="cm-variable">data</span> { <span class="cm-variable">acc</span> += <span class="cm-meta">#fmt</span>(<span class="cm-string">&quot;%02x&quot;</span>, <span class="cm-variable">byte</span> <span class="cm-keyword">as</span> <span class="cm-variable">uint</span>); }
    <span class="cm-keyword">ret</span> <span class="cm-variable">acc</span>;
}
<span class="cm-keyword">fn</span> <span class="cm-def">sha1</span>(<span class="cm-def">data</span>: <span class="cm-keyword">str</span>) -&gt; <span class="cm-keyword">str</span> <span class="cm-def">unsafe</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">bytes</span> = <span class="cm-variable-2">str::</span><span class="cm-variable">bytes</span>(<span class="cm-variable">data</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">hash</span> = <span class="cm-variable-2">crypto::</span><span class="cm-variable">SHA1</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">to_ptr</span>(<span class="cm-variable">bytes</span>),
                            <span class="cm-variable-2">vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">bytes</span>), <span class="cm-variable-2">ptr::</span><span class="cm-variable">null</span>());
    <span class="cm-keyword">ret</span> <span class="cm-variable">as_hex</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">from_buf</span>(<span class="cm-variable">hash</span>, <span class="cm-number">20</span><span class="cm-variable">u</span>));
}
<span class="cm-keyword">fn</span> <span class="cm-def">main</span>(<span class="cm-def">args</span>: [<span class="cm-keyword">str</span>]) {
    <span class="cm-variable-2">std::io::</span><span class="cm-variable">println</span>(<span class="cm-variable">sha1</span>(<span class="cm-variable">args</span>[<span class="cm-number">1</span>]));
}</pre>

<h2>Native modules</h2>

<p>Before we can call <code>SHA1</code>, we have to declare it. That is what this
part of the program is responsible for:</p>

<pre class="cm-s-default"><span class="cm-keyword">native</span> <span class="cm-keyword">mod</span> <span class="cm-def">crypto</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">SHA1</span>(<span class="cm-def">src</span>: *<span class="cm-keyword">u8</span>, <span class="cm-def">sz</span>: <span class="cm-keyword">uint</span>, <span class="cm-def">out</span>: *<span class="cm-keyword">u8</span>) -&gt; *<span class="cm-keyword">u8</span>;
}</pre>

<p>A <code>native</code> module declaration tells the compiler that the program
should be linked with a library by that name, and that the given list
of functions are available in that library.</p>

<p>In this case, it&#39;ll change the name <code>crypto</code> to a shared library name
in a platform-specific way (<code>libcrypto.so</code> on Linux, for example), and
link that in. If you want the module to have a different name from the
actual library, you can use the <code>&quot;link_name&quot;</code> attribute, like:</p>

<pre class="cm-s-default">#[<span class="cm-variable">link_name</span> = <span class="cm-string">&quot;crypto&quot;</span>]
<span class="cm-keyword">native</span> <span class="cm-keyword">mod</span> <span class="cm-def">something</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">SHA1</span>(<span class="cm-def">src</span>: *<span class="cm-keyword">u8</span>, <span class="cm-def">sz</span>: <span class="cm-keyword">uint</span>, <span class="cm-def">out</span>: *<span class="cm-keyword">u8</span>) -&gt; *<span class="cm-keyword">u8</span>;
}</pre>

<h2>Native calling conventions</h2>

<p>Most native C code use the cdecl calling convention, so that is what
Rust uses by default when calling native functions. Some native functions,
most notably the Windows API, use other calling conventions, so Rust
provides a way to to hint to the compiler which is expected by using
the <code>&quot;abi&quot;</code> attribute:</p>

<pre class="cm-s-default">#[<span class="cm-variable">cfg</span>(<span class="cm-variable">target_os</span> = <span class="cm-string">&quot;win32&quot;</span>)]
#[<span class="cm-variable">abi</span> = <span class="cm-string">&quot;stdcall&quot;</span>]
<span class="cm-keyword">native</span> <span class="cm-keyword">mod</span> <span class="cm-def">kernel32</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">SetEnvironmentVariableA</span>(<span class="cm-def">n</span>: *<span class="cm-keyword">u8</span>, <span class="cm-def">v</span>: *<span class="cm-keyword">u8</span>) -&gt; <span class="cm-keyword">int</span>;
}</pre>

<p>The <code>&quot;abi&quot;</code> attribute applies to a native mod (it can not be applied
to a single function within a module), and must be either <code>&quot;cdecl&quot;</code>
or <code>&quot;stdcall&quot;</code>. Other conventions may be defined in the future.</p>

<h2>Unsafe pointers</h2>

<p>The native <code>SHA1</code> function is declared to take three arguments, and
return a pointer.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">SHA1</span>(<span class="cm-def">src</span>: *<span class="cm-keyword">u8</span>, <span class="cm-def">sz</span>: <span class="cm-keyword">uint</span>, <span class="cm-def">out</span>: *<span class="cm-keyword">u8</span>) -&gt; *<span class="cm-keyword">u8</span>;</pre>

<p>When declaring the argument types to a foreign function, the Rust
compiler has no way to check whether your declaration is correct, so
you have to be careful. If you get the number or types of the
arguments wrong, you&#39;re likely to get a segmentation fault. Or,
probably even worse, your code will work on one platform, but break on
another.</p>

<p>In this case, <code>SHA1</code> is defined as taking two <code>unsigned char*</code>
arguments and one <code>unsigned long</code>. The rust equivalents are <code>*u8</code>
unsafe pointers and an <code>uint</code> (which, like <code>unsigned long</code>, is a
machine-word-sized type).</p>

<p>Unsafe pointers can be created through various functions in the
standard lib, usually with <code>unsafe</code> somewhere in their name. You can
dereference an unsafe pointer with <code>*</code> operator, but use
caution—unlike Rust&#39;s other pointer types, unsafe pointers are
completely unmanaged, so they might point at invalid memory, or be
null pointers.</p>

<h2>Unsafe blocks</h2>

<p>The <code>sha1</code> function is the most obscure part of the program.</p>

<pre class="cm-s-default"><span class="cm-keyword">fn</span> <span class="cm-def">sha1</span>(<span class="cm-def">data</span>: <span class="cm-keyword">str</span>) -&gt; <span class="cm-keyword">str</span> <span class="cm-def">unsafe</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">bytes</span> = <span class="cm-variable-2">str::</span><span class="cm-variable">bytes</span>(<span class="cm-variable">data</span>);
    <span class="cm-keyword">let</span> <span class="cm-def">hash</span> = <span class="cm-variable-2">crypto::</span><span class="cm-variable">SHA1</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">to_ptr</span>(<span class="cm-variable">bytes</span>),
                            <span class="cm-variable-2">vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">bytes</span>), <span class="cm-variable-2">ptr::</span><span class="cm-variable">null</span>());
    <span class="cm-keyword">ret</span> <span class="cm-variable">as_hex</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">from_buf</span>(<span class="cm-variable">hash</span>, <span class="cm-number">20</span><span class="cm-variable">u</span>));
}</pre>

<p>Firstly, what does the <code>unsafe</code> keyword at the top of the function
mean? <code>unsafe</code> is a block modifier—it declares the block following it
to be known to be unsafe.</p>

<p>Some operations, like dereferencing unsafe pointers or calling
functions that have been marked unsafe, are only allowed inside unsafe
blocks. With the <code>unsafe</code> keyword, you&#39;re telling the compiler &#39;I know
what I&#39;m doing&#39;. The main motivation for such an annotation is that
when you have a memory error (and you will, if you&#39;re using unsafe
constructs), you have some idea where to look—it will most likely be
caused by some unsafe code.</p>

<p>Unsafe blocks isolate unsafety. Unsafe functions, on the other hand,
advertise it to the world. An unsafe function is written like this:</p>

<pre class="cm-s-default"><span class="cm-keyword">unsafe</span> <span class="cm-keyword">fn</span> <span class="cm-def">kaboom</span>() { <span class="cm-string">&quot;I&#39;m harmless!&quot;</span>; }</pre>

<p>This function can only be called from an unsafe block or another
unsafe function.</p>

<h2>Pointer fiddling</h2>

<p>The standard library defines a number of helper functions for dealing
with unsafe data, casting between types, and generally subverting
Rust&#39;s safety mechanisms.</p>

<p>Let&#39;s look at our <code>sha1</code> function again.</p>

<pre class="cm-s-default"><span class="cm-keyword">let</span> <span class="cm-def">bytes</span> = <span class="cm-variable-2">str::</span><span class="cm-variable">bytes</span>(<span class="cm-variable">data</span>);
<span class="cm-keyword">let</span> <span class="cm-def">hash</span> = <span class="cm-variable-2">crypto::</span><span class="cm-variable">SHA1</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">to_ptr</span>(<span class="cm-variable">bytes</span>),
                        <span class="cm-variable-2">vec::</span><span class="cm-variable">len</span>(<span class="cm-variable">bytes</span>), <span class="cm-variable-2">ptr::</span><span class="cm-variable">null</span>());
<span class="cm-keyword">ret</span> <span class="cm-variable">as_hex</span>(<span class="cm-variable-2">vec::unsafe::</span><span class="cm-variable">from_buf</span>(<span class="cm-variable">hash</span>, <span class="cm-number">20</span><span class="cm-variable">u</span>));</pre>

<p>The <code>str::bytes</code> function is perfectly safe, it converts a string to
an <code>[u8]</code>. This byte array is then fed to <code>vec::unsafe::to_ptr</code>, which
returns an unsafe pointer to its contents.</p>

<p>This pointer will become invalid as soon as the vector it points into
is cleaned up, so you should be very careful how you use it. In this
case, the local variable <code>bytes</code> outlives the pointer, so we&#39;re good.</p>

<p>Passing a null pointer as third argument to <code>SHA1</code> causes it to use a
static buffer, and thus save us the effort of allocating memory
ourselves. <code>ptr::null</code> is a generic function that will return an
unsafe null pointer of the correct type (Rust generics are awesome
like that—they can take the right form depending on the type that they
are expected to return).</p>

<p>Finally, <code>vec::unsafe::from_buf</code> builds up a new <code>[u8]</code> from the
unsafe pointer that was returned by <code>SHA1</code>. SHA1 digests are always
twenty bytes long, so we can pass <code>20u</code> for the length of the new
vector.</p>

<h2>Passing structures</h2>

<p>C functions often take pointers to structs as arguments. Since Rust
records are binary-compatible with C structs, Rust programs can call
such functions directly.</p>

<p>This program uses the Posix function <code>gettimeofday</code> to get a
microsecond-resolution timer.</p>

<pre class="cm-s-default"><span class="cm-keyword">use</span> <span class="cm-variable">std</span>;
<span class="cm-keyword">type</span> <span class="cm-def">timeval</span> = {<span class="cm-keyword">mutable</span> <span class="cm-variable">tv_sec</span>: <span class="cm-keyword">u32</span>,
                <span class="cm-keyword">mutable</span> <span class="cm-variable">tv_usec</span>: <span class="cm-keyword">u32</span>};
#[<span class="cm-variable">nolink</span>]
<span class="cm-keyword">native</span> <span class="cm-keyword">mod</span> <span class="cm-def">libc</span> {
    <span class="cm-keyword">fn</span> <span class="cm-def">gettimeofday</span>(<span class="cm-def">tv</span>: *<span class="cm-variable-3">timeval</span>, <span class="cm-def">tz</span>: *()) -&gt; <span class="cm-keyword">i32</span>;
}
<span class="cm-keyword">fn</span> <span class="cm-def">unix_time_in_microseconds</span>() -&gt; <span class="cm-keyword">u64</span> <span class="cm-def">unsafe</span> {
    <span class="cm-keyword">let</span> <span class="cm-def">x</span> = {<span class="cm-keyword">mutable</span> <span class="cm-variable">tv_sec</span>: <span class="cm-number">0u32</span>, <span class="cm-keyword">mutable</span> <span class="cm-variable">tv_usec</span>: <span class="cm-number">0u32</span>};
    <span class="cm-variable-2">libc::</span><span class="cm-variable">gettimeofday</span>(<span class="cm-variable-2">ptr::</span><span class="cm-variable">addr_of</span>(<span class="cm-variable">x</span>), <span class="cm-variable-2">ptr::</span><span class="cm-variable">null</span>());
    <span class="cm-keyword">ret</span> (<span class="cm-variable">x</span>.<span class="cm-variable">tv_sec</span> <span class="cm-keyword">as</span> <span class="cm-variable">u64</span>) * <span class="cm-number">1000</span><span class="cm-variable">_000_u64</span> + (<span class="cm-variable">x</span>.<span class="cm-variable">tv_usec</span> <span class="cm-keyword">as</span> <span class="cm-variable">u64</span>);
}</pre>

<p>The <code>#[nolink]</code> attribute indicates that there&#39;s no native library to link
in. The standard C library is already linked with Rust programs.</p>

<p>A <code>timeval</code>, in C, is a struct with two 32-bit integers. Thus, we
define a record type with the same contents, and declare
<code>gettimeofday</code> to take a pointer to such a record.</p>

<p>The second argument to <code>gettimeofday</code> (the time zone) is not used by
this program, so it simply declares it to be a pointer to the nil
type. Since null pointer look the same, no matter which type they are
supposed to point at, this is safe.</p></div><p class="head">Section 11 of the Rust language tutorial.<br><a href="iface.html">« Section 10</a> | <a href="index.html">Index</a> | <a href="task.html">Section 12 »</a></p><p class='head'>Created October 1, 2011, last modified on  12, 2012</p></body></html>